<html>
  <head>
    <title>Moles Evaluation</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  </head>
  <body>
    <h1>Moles Evaluation</h1>
    <p>See&nbsp;<a href="https://github.com/duderino/injection/tree/master/MolesTest">https://github.com/duderino/injection/tree/master/MolesTest</a>
      for complete source code.<br>
    </p>
    <p> </p>
    <h2>1. Inject mocks/stubs without changing the API</h2>
    Class.cs:<br>
    <pre>    public class Class01
    {
        private Dependency01 dependency = new Dependency01();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }
<br></pre> Dependency.cs:<br>
    <pre>    public class Dependency01
    {
        public virtual int generate()
        {
            return 999;
        }
    }<br></pre>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest01
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MDependency01.AllInstances.generate = _ =&gt; 123;
            
            Class01 clazz = new Class01();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }<br></pre>
    <h2>2. Mock/stub out final/non-virtual functions</h2>
    Class.cs:<br>
    <pre>    public class Class02
    {
        private Dependency02 dependency = new Dependency02();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }
<br></pre>Removed virtual keyword from generate method and made the class sealed
    <br>
    <br>
    Dependency.cs:<br>
    <pre>    public sealed class Dependency02
    {
        public int generate()
        {
            return 999;
        }
    }<br><br></pre>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest02
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MDependency02.AllInstances.generate = _ =&gt; 123;
            
            Class02 clazz = new Class02();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }<br></pre>
    <h2>3. Mock/stub out static functions</h2>
    Here we change our dependency's method to be static.<br>
    <br>
    Dependency.cs:<br>
    <pre>    public static class Dependency03
    {
        public static int generate()
        {
            return 999;
        }
    }
</pre> The class under test no longer instantiates the dependency and instead
    calls its static method.<br>
    <br>
    Class.cs:<br>
    <pre>    public class Class03
    {
        public int generate()
        {
            return Dependency03.generate() * 2;
        }
    }
<br></pre>The static method can be mocked using the MDependency03.generate
    delegate.&nbsp;&nbsp; Use of the AllInstances inner class is not required
    for mocking out static functions.<br>
    <br>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest03
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MDependency03.generate = () =&gt; 123;
            
            Class03 clazz = new Class03();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }</pre>
    <h2>4. Mock/stub out constructors</h2>
    Here we change our dependency to take an argument in its constructor.<br>
    <br>
    Dependency.cs:<br>
    <pre>    public class Dependency04
    {
        private int value;

        public Dependency04(int value)
        {
            this.value = value;
        }

        public int generate()
        {
            return value;
        }
    }
</pre><br>
    <br>
    Class.cs:<br>
    <pre>    public class Class04
    {
        private Dependency04 dependency = new Dependency04(999);

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }
<br></pre>TODO - assert on values passed to ctor.&nbsp;&nbsp; can also
    dynamically modify mock in its ctor.<br>
    <br>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest04
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MDependency04.ConstructorInt32 = (@this, value) =&gt; { 
                Assert.AreEqual(999, value);

                var mole = new MDependency04(@this) { generate = () =&gt; 123 }; 
            };
            
            Class04 clazz = new Class04();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }
</pre>
    <h2>5. Mock/stub out anonymous inner/nested classes</h2>
    This is not applicable to C#.&nbsp;&nbsp; While C# has anonymous classes,
    they cannot implement an interface but are instead limited to a collection
    of simple, read-only properties.&nbsp;&nbsp; This class to test, for
    instance, is so contrived it's not very useful.&nbsp;&nbsp; The anonymous
    class is really a hard-coded constant and not a true dependency.<br>
    <pre>    public class Class05
    {
        public int generate()
        {
            var dependency = new { generate = 999 };

            return dependency.generate * 2;
        }
    }<br></pre>
    <h2>6. Mock/stub out inaccessible (e.g., private) inner/nested classes</h2>
    Extending on the previous example, it appears that JMockit must have access
    to the definition of every class it needs to mock out.&nbsp;&nbsp; Private
    inner classes, static or not, are not visible to the JMockit annotations so
    they break compilation.<br>
    <br>
    For this test we moved the Dependency class into the Class class.<br>
    <br>
    Class.cs:<br>
    <pre>public class Class {
    private static class Dependency {
        public int generate() {
            return (int) Math.random() * 1000;
        }
    }

    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}<br></pre>
    Next we tried to inject a mock implementation in the test case.<br>
    <br>
    ClassTest.cs:<br>
    <pre>public class ClassTest {
    @MockClass(realClass = Class.Dependency.class)
    public static class MockDependency {
        @Mock
        public int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Class.Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}

</pre> The result was a predictable compilation error:<br>
    <pre>[INFO] -------------------------------------------------------------
[ERROR] COMPILATION ERROR : 
[INFO] -------------------------------------------------------------
[ERROR] /Users/blattj/dev/injection/src/test/java/org/duderino/injection/jmockit/_6/ClassTest.cs:[12,32] org.duderino.injection.jmockit._6.Class.Dependency has private access in org.duderino.injection.jmockit._6.Class
[ERROR] /Users/blattj/dev/injection/src/test/java/org/duderino/injection/jmockit/_6/ClassTest.cs:[22,30] org.duderino.injection.jmockit._6.Class.Dependency has private access in org.duderino.injection.jmockit._6.Class
[INFO] 2 errors 

<br></pre>The same results were observed by omitting the 'static' qualifier.<br>
    <h2>7. Mock/stub out base/superclass functions</h2>
    <p>TODO - mock out 1 method in superclass and 1 method in
      subclass.&nbsp;&nbsp; Might be an exclusive OR.</p>
    <h2>8. Inject a mock that delegates to a real instance</h2>
    <p>TODO - rename these in source code from here down - add 1 to package.<br>
    </p>
    Since we want to make sure we call the real dependency, we first change it
    to return a constant rather than the random number used in previous
    examples.&nbsp;&nbsp; Our test case will assert later that this constant was
    in fact returned.<br>
    <br>
    Dependency.java:<br>
    <pre>public class Dependency {
    public int generate() {
        return 123;
    }
}
</pre> And the class under test instantiates and calls the dependency as usual.<br>
    <br>
    Class.java:<br>
    <pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}
<br></pre> So we save all the complexity for the test case...<br>
    <br>
    ClassTest.java:<br>
    <pre>public class ClassTest {
    @Test
    public void testIt() {
        final List&lt;Integer&gt; calls = new ArrayList&lt;Integer&gt;();

        Mockit.setUpMock(Dependency.class, new Dependency() {
            //private int numCalls = 0;
            public Dependency it;

            @Mock(reentrant = true)
            @Override
            public int generate() {
                int result = it.generate();

                calls.add(new Integer(result));

                return result;
            }
        });

        Class clazz = new Class();

        for (int i = 0; i &lt; 10; ++i) {
            assert 123 * 2 == clazz.generate();
        }

        assert calls.size() == 10;
    }
}</pre>
    Several special things have to happen when we setup this mock object.<br>
    <br>
    We have to declare a 'public Dependency it;' member.&nbsp;&nbsp; All three
    tokens are important here.&nbsp;&nbsp; If the member is declared private,
    JMockit will throw an exception that looks like this:<br>
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 7, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.529 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._7.ClassTest)  Time elapsed: 0.012 sec  &lt;&lt;&lt; FAILURE!
java.lang.IllegalAccessError: tried to access field org.duderino.injection.jmockit._7.ClassTest$1.it from class org.duderino.injection.jmockit._7.Dependency
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
	at org.duderino.injection.jmockit._7.Class.generate(Class.java:10)
	at org.duderino.injection.jmockit._7.ClassTest.testIt(ClassTest.java:37)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._7.ClassTest): tried to access field org.duderino.injection.jmockit._7.ClassTest$1.it from class org.duderino.injection.jmockit._7.Dependency

Tests run: 7, Failures: 1, Errors: 0, Skipped: 0
<br></pre> Assuming there is a publicly accessible 'it' member with the same
    type as the real, non-mocked instance, JMockit will automatically copy the
    real, non-mocked instance reference into the 'it' attribute.&nbsp;&nbsp;
    While not tested, getting the data type wrong would probably produced a
    ClassCastException.<br>
    <br>
    The other special gotcha is the 'reentrant = true' qualifier on the @Mock
    annotation.&nbsp;&nbsp; Without this qualifier JMockit will still redirect
    calls to the real instance to the mock.&nbsp;&nbsp; That is, the mock will
    call itself recursively, generating a stack overflow that looks like this:<br>
    <br>
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 7, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.668 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._7.ClassTest)  Time elapsed: 0.095 sec  &lt;&lt;&lt; FAILURE!
java.lang.StackOverflowError
	at java.util.HashMap.get(HashMap.java:298)
	at java.util.Collections$SynchronizedMap.get(Collections.java:1975)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.java:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.java:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
<br>...<br>	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.java:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._7.ClassTest)

Tests run: 7, Failures: 1, Errors: 0, Skipped: 0
<br></pre>
    <h2>9. Inject hand-coded mocks or stubs </h2>
    Well, this one is kinda a 'duh'.&nbsp; Every example so far has injected a
    hand-coded mock. <br>
    <h2>10. Mocks injection can be narrowly targeted</h2>
    <br>
    <h3>Lesson Learned: Mocking Out The Java Class Library Is Dangerous</h3>
    Configuration.java<br>
    <pre>package org.duderino.injection.jmockit._1;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.FileInputStream;
import java.util.HashMap;
import java.util.Map;

public class Configuration {
    private Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    private final String path;

    public Configuration(String path) throws Exception {
        this.path = path;

        reload();
    }

    public String get(String key) {
        return map.get(key);
    }

    public void reload() throws Exception {
        map.clear();

        DocumentBuilder docBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();

        Document document = docBuilder.parse(new FileInputStream(path));

        NodeList settings = document.getElementsByTagName("setting");

        for (int i = 0; i &lt; settings.getLength(); ++i) {
            Node setting = settings.item(i);

            NodeList children = setting.getChildNodes();

            String key = null;
            String value = null;

            for (int j = 0; j &lt; children.getLength(); ++j) {
                Node child = children.item(j);

                if ("key".equals(child.getNodeName())) {
                    key = child.getNodeValue();
                    continue;
                }

                if ("value".equals(child.getNodeName())) {
                    value = child.getNodeValue();
                    continue;
                }
            }

            if (null != key) {
                map.put(key, value);
            }
        }
    }
}
<br></pre> ConfigurationTest.java<br>
    <pre>package org.duderino.injection.jmockit._1;

import mockit.Mock;
import mockit.Mockit;
import org.testng.annotations.Test;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

public class ConfigurationTest {
    @Test
    public void testCheck() throws Exception {
        final String xml = "&lt;settings&gt;&lt;setting&gt;&lt;key&gt;foo&lt;/key&gt;&lt;value&gt;bar&lt;/value&gt;&lt;/setting&gt;&lt;/settings&gt;";

        Mockit.setUpMock(FileInputStream.class, new InputStream() {
            private byte[] bytes = xml.getBytes("UTF-8");
            private int index = 0;

            @Mock
            public int read() throws IOException {
                if (index &gt;= bytes.length) {
                    return 0;
                }

                return bytes[index++];
            }

            @Mock
            private void open(String name) throws FileNotFoundException {
                // do nothing
            }
        });

        Configuration configuration = new Configuration("dummy path");

        assert "bar".equals(configuration.get("foo"));
    }
}
<br></pre> Output:<br>
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running TestSuite
WARNING: JMockit was initialized on demand, which may cause certain tests to fail;
please check the documentation for better ways to get it initialized.
ZoneInfo: Bad file descriptor
ZoneInfo: Bad file descriptor
ZoneInfo: Bad file descriptor
Tests run: 2, Failures: 2, Errors: 0, Skipped: 0, Time elapsed: 0.779 sec &lt;&lt;&lt; FAILURE!
testCheck(org.duderino.injection.jmockit._1.ConfigurationTest)  Time elapsed: 0.382 sec  &lt;&lt;&lt; FAILURE!
java.lang.NoClassDefFoundError: org/duderino/injection/jmockit/_1/Configuration
	at org.duderino.injection.jmockit._1.ConfigurationTest.testCheck(ConfigurationTest.java:36)
Caused by: java.lang.ClassNotFoundException: org.duderino.injection.jmockit._1.Configuration
	at java.net.URLClassLoader$1.run(URLClassLoader.java:199)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
	... 35 more
Caused by: java.io.IOException: Bad file descriptor
	at java.io.FileInputStream.readBytes(Native Method)
	at java.io.FileInputStream.read(FileInputStream.java:220)
	at sun.misc.Resource.getBytes(Resource.java:108)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:257)
	at java.net.URLClassLoader.access$000(URLClassLoader.java:58)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:197)
	... 40 more
testCheck(org.duderino.injection.jmockit.basic.Y2KCheckerTest)  Time elapsed: 0.01 sec  &lt;&lt;&lt; FAILURE!
<br></pre> <br>
    <h2>11. Generate basic stubs </h2>
    <h2>12. Generate basic mocks</h2>
    <h2>13. Generate async-friendly mocks</h2>
    <h2>14. Generate thread-friendly mocks</h2>
    <h2>15. Associate assertions in hand-coded mocks or stubs with test cases in
      same thread</h2>
    <h2>16. Associate assertions in hand-coded mocks or stubs with test cases in
      different thread</h2>
    <br>
  </body>
</html>
