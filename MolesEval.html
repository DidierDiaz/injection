<html>
  <head>
    <title>Moles Evaluation</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  </head>
  <body>
    <h1>Moles Evaluation</h1>
    <p>See&nbsp;<a href="https://github.com/duderino/injection/tree/master/MolesTest">https://github.com/duderino/injection/tree/master/MolesTest</a>
      for complete source code.<br>
    </p>
    <p> </p>
    <h2>1. Inject mocks/stubs without changing the API</h2>
    Class.cs:<br>
    <pre>    public class Class01
    {
        private Dependency01 dependency = new Dependency01();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }
<br></pre> Dependency.cs:<br>
    <pre>    public class Dependency01
    {
        public virtual int generate()
        {
            return 999;
        }
    }<br></pre>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest01
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MDependency01.AllInstances.generate = _ =&gt; 123;
            
            Class01 clazz = new Class01();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }<br></pre>
    <h2>2. Mock/stub out final/non-virtual functions</h2>
    Class.cs:<br>
    <pre>    public class Class02
    {
        private Dependency02 dependency = new Dependency02();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }
<br></pre>Removed virtual keyword from generate method and made the class sealed
    <br>
    <br>
    Dependency.cs:<br>
    <pre>    public sealed class Dependency02
    {
        public int generate()
        {
            return 999;
        }
    }<br><br></pre>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest02
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MDependency02.AllInstances.generate = _ =&gt; 123;
            
            Class02 clazz = new Class02();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }<br></pre>
    <h2>3. Mock/stub out static functions</h2>
    Here we change our dependency's method to be static.<br>
    <br>
    Dependency.cs:<br>
    <pre>    public static class Dependency03
    {
        public static int generate()
        {
            return 999;
        }
    }
</pre> The class under test no longer instantiates the dependency and instead
    calls its static method.<br>
    <br>
    Class.cs:<br>
    <pre>    public class Class03
    {
        public int generate()
        {
            return Dependency03.generate() * 2;
        }
    }
<br></pre>The static method can be mocked using the MDependency03.generate
    delegate.&nbsp;&nbsp; Use of the AllInstances inner class is not required
    for mocking out static functions.<br>
    <br>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest03
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MDependency03.generate = () =&gt; 123;
            
            Class03 clazz = new Class03();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }</pre>
    <h2>4. Mock/stub out constructors</h2>
    Here we change our dependency to take an argument in its constructor.<br>
    <br>
    Dependency.cs:<br>
    <pre>    public class Dependency04
    {
        private int value;

        public Dependency04(int value)
        {
            this.value = value;
        }

        public int generate()
        {
            return value;
        }
    }
</pre><br>
    <br>
    Class.cs:<br>
    <pre>    public class Class04
    {
        private Dependency04 dependency = new Dependency04(999);

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }
<br></pre>TODO - assert on values passed to ctor.&nbsp;&nbsp; can also
    dynamically modify mock in its ctor.<br>
    <br>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest04
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MDependency04.ConstructorInt32 = (@this, value) =&gt; { 
                Assert.AreEqual(999, value);

                var mole = new MDependency04(@this) { generate = () =&gt; 123 }; 
            };
            
            Class04 clazz = new Class04();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }
</pre>
    <h2>5. Mock/stub out anonymous inner/nested classes</h2>
    This is not applicable to C#.&nbsp;&nbsp; While C# has anonymous classes,
    they cannot implement an interface but are instead limited to a collection
    of simple, read-only properties.&nbsp;&nbsp; This class to test, for
    instance, is so contrived it's not very useful.&nbsp;&nbsp; The anonymous
    class is really a hard-coded constant and not a true dependency.<br>
    <pre>    public class Class05
    {
        public int generate()
        {
            var dependency = new { generate = 999 };

            return dependency.generate * 2;
        }
    }<br></pre>
    <h2>6. Mock/stub out inaccessible (e.g., private) inner/nested classes</h2>
    For this test we moved the Dependency class into the Class class.<br>
    <br>
    Class.cs:<br>
    <pre>    public class Class06
    {
        private class Dependency06
        {
            public int generate()
            {
                return 999;
            }
        }

        private Dependency06 dependency = new Dependency06();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }<br></pre>
    <br>
    <br>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest04
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MClass06.MDependency06.AllInstances.generate = _ =&gt; 123;

            Class06 clazz = new Class06();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }

</pre> The result was a compilation error:<br>
    <pre>------ Build started: Project: MolesTest, Configuration: Debug Any CPU ------
  MolesTest -&gt; C:\Users\foo\Documents\Visual Studio 2010\Projects\MolesTest\MolesTest\bin\Debug\MolesTest.dll
------ Build started: Project: MolesTest.Tests, Configuration: Debug Any CPU ------
C:\Users\foo\Documents\Visual Studio 2010\Projects\MolesTest\MolesTest.Tests05\_6\ClassTest06.cs(22,22): error CS0117: 'MolesTest._6.Moles.MClass06' does not contain a definition for 'MDependency06'

Compile complete -- 1 errors, 0 warnings
  Microsoft Moles v0.94.51006.1 - http://research.microsoft.com/moles - .NET v4.0.30319
  Copyright (c) Microsoft Corporation 2007-2010. All rights reserved.
  
  Generating 2 Moles assemblies with 2 concurrent processes
  3:start&gt; MolesTest.moles
  4:start&gt; mscorlib.moles
  4:end&gt; mscorlib.moles Success (0 - 0x0)
  3:end&gt; MolesTest.moles Success (0 - 0x0)
  
  	Moles compilation SUCCESS - 2.5885226s
========== Build: 1 succeeded or up-to-date, 1 failed, 0 skipped ==========
<br></pre>The same test works if the accessibility of the Dependency06 class is
    changed from private to public.&nbsp;&nbsp; We also tried making the
    internals visible to Moles by adding these two lines to the assembly, but
    they did not help:<br>
    <pre>[assembly: InternalsVisibleTo("MolesTest._6.Moles")]
[assembly: InternalsVisibleTo("MolesTest.Moles")]<br></pre>
    <h2>7. Mock/stub out subclass and superclass functions</h2>
    <p>SuperDepenency.cs:<br>
    </p>
    <pre>    public class SuperDependency07
    {
        public virtual int generate()
        {
            return 999;
        }

        public int superGenerate()
        {
            return 999;
        }
    }<br></pre>
    SubDependency.cs:<br>
    <pre>    public class SubDependency07 : SuperDependency07
    {
        public override int generate()
        {
            return 333;
        }

        public int subGenerate()
        {
            return 333;
        }
    }<br></pre>
    Class.cs:<br>
    <pre>    public class Class07
    {
        private SubDependency07 dependency = new SubDependency07();

        public int generate()
        {
            return 2 * dependency.generate();
        }

        public int superGenerate()
        {
            return 2 * dependency.superGenerate();
        }

        public int subGenerate()
        {
            return 2 * dependency.subGenerate();
        }
    }<br></pre>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest07
    {
        [TestMethod]
        [HostType("Moles")]
        public void testOverride()
        {
            MSubDependency07.AllInstances.generate = _ =&gt; 123;

            Class07 clazz = new Class07();

            Assert.AreEqual(2 * 123, clazz.generate());
            Assert.AreEqual(2 * 333, clazz.subGenerate());
            Assert.AreEqual(2 * 999, clazz.superGenerate());
        }

        [TestMethod]
        [HostType("Moles")]
        public void testOvershadow()
        {
            MSuperDependency07.AllInstances.generate = _ =&gt; 123;

            Class07 clazz = new Class07();

            Assert.AreEqual(2 * 333, clazz.generate());
            Assert.AreEqual(2 * 333, clazz.subGenerate());
            Assert.AreEqual(2 * 999, clazz.superGenerate());
        }

        [TestMethod]
        [HostType("Moles")]
        public void testSuper()
        {
            // does not compile: MSubDependency07.AllInstances.superGenerate = _ =&gt; 123;

            MSuperDependency07.AllInstances.superGenerate = _ =&gt; 123;

            Class07 clazz = new Class07();

            Assert.AreEqual(2 * 333, clazz.generate());
            Assert.AreEqual(2 * 333, clazz.subGenerate());
            Assert.AreEqual(2 * 123, clazz.superGenerate());
        }

        [TestMethod]
        [HostType("Moles")]
        public void testSub()
        {
            MSubDependency07.AllInstances.subGenerate = _ =&gt; 123;

            Class07 clazz = new Class07();

            Assert.AreEqual(2 * 333, clazz.generate());
            Assert.AreEqual(2 * 123, clazz.subGenerate());
            Assert.AreEqual(2 * 999, clazz.superGenerate());
        }
    }<br></pre>
    <pre></pre>
    <h2>8. Inject a mock that delegates to a real instance</h2>
    Dependency.java:<br>
    <pre>    public class Dependency08
    {
        public int generate()
        {
            return 999;
        }
    }
</pre> <br>
    Class.java:<br>
    <pre>    public class Class08
    {
        private Dependency08 dependency = new Dependency08();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }
<br></pre> So we save all the complexity for the test case...<br>
    <br>
    ClassTest.java:<br>
    <pre>    [TestClass]
    public class ClassTest01
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            int count = 0;

            MDependency08.AllInstances.generate = (Dependency08 dependency) =&gt;
            {
                ++count;

                return MolesContext.ExecuteWithoutMoles(() =&gt; {
                    return dependency.generate();
                });
            };
            
            Class08 clazz = new Class08();

            for (int i = 0; i &lt; 10; ++i)
            {
                Assert.AreEqual(2 * 999, clazz.generate());
            }

            Assert.AreEqual(10, count);
        }
    }</pre>
    <br>
    <h2>9. Inject hand-coded mocks or stubs </h2>
    Dependency.cs:<br>
    <pre>    public class Dependency09
    {
        public int generate()
        {
            return 999;
        }
    }<br></pre>
    Class.cs:<br>
    <pre>    public class Class09
    {
        private Dependency09 dependency = new Dependency09();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }<br></pre>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest09
    {
        private class MockDependency
        {
            private int value = 123;

            public int generate()
            {
                return value;
            }
        }

        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            // While this works, it doesn't appear to be threadsafe.

            MockDependency mockDependency = new MockDependency();

            MDependency09.AllInstances.generate = _ =&gt;
            {
                return mockDependency.generate();
            };
            
            Class09 clazz = new Class09();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }<br></pre>
    <h2>10. Mock/stub injection can be toggled</h2>
    Dependency.cs:<br>
    <pre>    public class Dependency10
    {
        public int generate()
        {
            return 999;
        }
    }
</pre> Class.cs:<br>
    <pre>    public class Class10
    {
        private Dependency10 dependency = new Dependency10();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }
<br></pre> ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest01
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MDependency10.AllInstances.generate = _ =&gt; 123;
            
            Class10 clazz = new Class10();

            Assert.AreEqual(2 * 123, clazz.generate());

            MDependency10.AllInstances.generate = null;

            Assert.AreEqual(2 * 999, clazz.generate());
        }
    }</pre>
    <h2>11. Mock/stub injection can be narrowly targeted</h2>
    Dependency.cs:<br>
    <pre>    public class Dependency11
    {
        public virtual int generate()
        {
            return 999;
        }
    }
</pre> Class.cs:<br>
    <pre>    public class Class11
    {
        private Dependency11 dependency = new Dependency11();

        public int generate()
        {
            int result = dependency.generate();

            return result + dependency.generate();
        }
    }<br></pre>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest11
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MDependency11.AllInstances.generate = _ =&gt; 123;

            Class11 clazz = new Class11();

            // No way to mock out the first generate call but not the second, so this will fail: Assert.AreEqual(123 + 999, clazz.generate());

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }</pre>
    <h2>12. Mock/stub out any implementation of an interface</h2>
    <p>TODO - use case - dependency injection frameworks where the
      implementation of an interface is not known in advance and the code under
      test only knows of the interface.</p>
    <p>Dependency.cs:<br>
    </p>
    <pre>    public interface Dependency12
    {
        int generate();
    }
</pre> Class.cs:<br>
    <pre>    public class Class12
    {
        // Make this public so Moles can generate a mole for it
        public class DependencyImpl : Dependency12
        {
            public int generate()
            {
                return 999;
            }
        }

        private Dependency12 dependency = new DependencyImpl();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }<br></pre>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest12
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            // Does not compile: MDependency12.AllInstances.generate = _ =&gt; 123;

            Class12 clazz = new Class12();

            // Does not pass because could not inject stub:  Assert.AreEqual(2 * 123, clazz.generate());

            Assert.AreEqual(2 * 999, clazz.generate());
        }
    }</pre>
    <h2>13. Safely mock/stub out class library</h2>
    Class.cs:<br>
    <pre>    public class Class13
    {
        public int generate1() 
        {
            StreamReader reader = File.OpenText("foo.txt");

            string line = reader.ReadLine();

            return 2 * int.Parse(line);
        }

        public int generate2()
        {
            FileStream stream = File.Open("foo", FileMode.Open);

            StreamReader reader = new StreamReader(stream);

            string line = reader.ReadLine();

            return 2 * int.Parse(line);
        }
    }<br></pre>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest13
    {
        [TestMethod]
        [HostType("Moles")]
        public void test1()
        {
            MFile.OpenTextString = _ =&gt; new MStreamReader();

            MStreamReader.AllInstances.ReadLine = _ =&gt; "123";

            Class13 clazz = new Class13();

            Assert.AreEqual(2 * 123, clazz.generate1());
        }

 
        [TestMethod]
        [HostType("Moles")]
        public void test2()
        {
            MemoryStream memoryStream = new MemoryStream(new byte[] { 0x31, 0x32, 0x33 });   // "123" in ascii/unicode hex

            MFileStream  mFileStream = new MFileStream();

            mFileStream.CanReadGet = () =&gt; memoryStream.CanRead;

            mFileStream.ReadByteArrayInt32Int32 = (byte[] array, int offset, int length) =&gt; memoryStream.Read(array, offset, length);

            MFile.OpenStringFileMode = (string path, FileMode mode) =&gt; mFileStream;

            Class13 clazz = new Class13();

            Assert.AreEqual(2 * 123, clazz.generate2());
        }
    }</pre>
    <p></p>
    <h2>14. Generate basic stubs </h2>
    <h2>15. Generate basic mocks</h2>
    <h2>16. Generate async-friendly mocks</h2>
    <h2>17. Generate thread-friendly mocks</h2>
    <h2>18. Associate assertions in hand-coded mocks or stubs with test cases in
      same thread</h2>
    <h2>19. Associate assertions in hand-coded mocks or stubs with test cases in
      different thread</h2>
    <br>
  </body>
</html>
