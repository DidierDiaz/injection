<html>
  <head>
    <title>Moles Evaluation</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  </head>
  <body>
    <h1>Moles Evaluation</h1>
    <p>See https://github.com/duderino/injection/tree/master/MolesTest for
      complete source code.<br>
    </p>
    <p> </p>
    <h2>1. Inject mocks/stubs without changing the API</h2>
    Class.cs:<br>
    <pre>namespace MolesTest._1
{
    public class Class
    {
        private Dependency dependency = new Dependency();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }
}
<br></pre>
    Dependency.cs:<br>
    <pre>namespace MolesTest._1
{
    public class Dependency
    {
        public virtual int generate()
        {
            Random random = new Random();

            return random.Next(0, 1000);
        }
    }
}<br></pre>
    ClassTest.cs:<br>
    <pre>using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.Moles.Framework;
using MolesTest._1;
using MolesTest._1.Moles;
<br>namespace MolesTest.Tests._1
{
    [TestClass]
    public class ClassTest
    {
        [TestMethod]
        [HostType("Moles")]
        public void test1()
        {
            MDependency.AllInstances.generate = _ =&gt; 123;
            
            Class clazz = new Class();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }
}<br></pre>
    <h2>2. Mock/stub out final/non-virtual functions</h2>
    Class.cs:<br>
    <pre>namespace MolesTest._2
{
    public class Class
    {
        private Dependency dependency = new Dependency();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }
}
<br>Removed virtual keyword from generate method -<br></pre>
    Dependency.cs:<br>
    <pre>namespace MolesTest._2
{
    public class Dependency
    {
        public int generate()
        {8
            Random random = new Random();

            return random.Next(0, 1000);
        }
    }
}<br><br></pre>
    Note the appended 01 in the MDependency01 moles type even though it's in a
    different namespace as the MDependency moles type used in our previous
    example (MolesTest._1.Moles.MDependency vs
    MolesTest._2.Moles.MDependency01).&nbsp;&nbsp; Moles type naming apparently
    tries to avoid unintentional type name collisions.<br>
    <br>
    ClassTest.cs:<br>
    <pre>using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.Moles.Framework;
using MolesTest._2;
using MolesTest._2.Moles;<br><br>namespace MolesTest.Tests._2
{
    [TestClass]
    public class ClassTest
    {
        [TestMethod]
        [HostType("Moles")]
        public void test2()
        {
            MDependency01.AllInstances.generate = _ =&gt; 123;
            
            Class clazz = new Class();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }
}<br><br></pre>
    For clarity, 'using' statements and appended '0n' moles type suffixes will
    be excluded from subsequent examples.&nbsp;&nbsp; The source code checked
    into https://github.com/duderino/injection/tree/master/MolesTest still has
    these, however.
    <h2>3. Mock/stub out static functions</h2>
    Here we change our dependency's method to be static.<br>
    <br>
    Dependency.cs:<br>
    <pre>public class Dependency {
    public static int generate() {
        return (int) Math.random() * 1000;
    }
}
</pre>
    The class under test no longer instantiates the dependency and instead calls
    its static method.<br>
    <br>
    Class.cs:<br>
    <pre>public class Class {
    public int generate() {
        return Dependency.generate() * 2;
    }
}
<br></pre>The static method can be mocked out using the same mechanism used in
    the previous example.<br>
    <br>
    ClassTest.cs:<br>
    <pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        public static int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}</pre>
    <h2>4. Mock/stub out constructors</h2>
    Here we change our dependency to take an argument in its constructor.<br>
    <br>
    Dependency.cs:<br>
    <pre>public class Dependency {
    private final int max;

    public Dependency(int max) {
        this.max = max;
    }

    public int generate() {
        return (int) Math.random() * max;
    }
}
</pre>
    The class under test is similarly modified to pass the argument through its
    constructor to the dependency's constructor.<br>
    <br>
    Class.cs:<br>
    <pre>public class Class {
    private final Dependency dependency;

    public Class(int max) {
        dependency = new Dependency(max);
    }

    public int generate() {
        return dependency.generate() * 2;
    }
}
<br></pre>
    Finally the test case is modified to pass the argument to the
    constructor.&nbsp;&nbsp; By defining a special "void $init()" method, the
    mock can verify that the constructor was passed the correct value.<br>
    <br>
    ClassTest.cs:<br>
    <pre>public class ClassTest {
    private static final int MAX = 1000;

    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        void $init(int max) {
            assert MAX == max;
        }

        @Mock
        public static int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class(MAX);

        assert 123 * 2 == clazz.generate();
    }
}
</pre>
    <h2>5. Mock/stub out anonymous inner classes</h2>
    Sometimes the class under test creates an anonymous inner class that we'd
    like to mock out.&nbsp;&nbsp; This is a particularly hard problem because
    the inner class may call back on the class under test's internals.<br>
    <br>
    Either JMockit does not support this or I simply couldn't figure out how to
    do it.&nbsp;&nbsp; This is what I tried to do...<br>
    <br>
    First, I turned the Dependency into an interface.<br>
    <br>
    Dependency.cs:<br>
    <pre>public interface Dependency {
    int generate();
}
</pre>
    Next I modified the class under test to instantiate an anonymous
    implementation of the interface.<br>
    <br>
    Class.cs:<br>
    <pre>public class Class {
    public int generate() {
       Dependency dependency = new Dependency() {
           @Override
           public int generate() {
               return (int) Math.random() * 1000;
           }
       };

        return dependency.generate() * 2;
    }
}<br></pre>
    Finally the test case was modified to inject a mock version of the
    Dependency.<br>
    <br>
    ClassTest.cs:<br>
    <pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        public int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}
</pre>
    Unfortunately JMockit threw a "Not a modifiable class"
    IllegalArgumentException when the test was run:<br>
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 1, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.42 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._5.ClassTest)  Time elapsed: 0.033 sec  &lt;&lt;&lt; FAILURE!
java.lang.IllegalArgumentException: Not a modifiable class: org.duderino.injection.jmockit._5.Dependency
	at org.duderino.injection.jmockit._5.ClassTest.testIt(ClassTest.cs:22)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._5.ClassTest): Not a modifiable class: org.duderino.injection.jmockit._5.Dependency

Tests run: 1, Failures: 1, Errors: 0, Skipped: 0
<br></pre>
    <h2>6. Mock/stub out inaccessible (e.g., private) inner classes</h2>
    Extending on the previous example, it appears that JMockit must have access
    to the definition of every class it needs to mock out.&nbsp;&nbsp; Private
    inner classes, static or not, are not visible to the JMockit annotations so
    they break compilation.<br>
    <br>
    For this test we moved the Dependency class into the Class class.<br>
    <br>
    Class.cs:<br>
    <pre>public class Class {
    private static class Dependency {
        public int generate() {
            return (int) Math.random() * 1000;
        }
    }

    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}<br></pre>
    Next we tried to inject a mock implementation in the test case.<br>
    <br>
    ClassTest.cs:<br>
    <pre>public class ClassTest {
    @MockClass(realClass = Class.Dependency.class)
    public static class MockDependency {
        @Mock
        public int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Class.Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}

</pre>
    The result was a predictable compilation error:<br>
    <pre>[INFO] -------------------------------------------------------------
[ERROR] COMPILATION ERROR : 
[INFO] -------------------------------------------------------------
[ERROR] /Users/blattj/dev/injection/src/test/java/org/duderino/injection/jmockit/_6/ClassTest.cs:[12,32] org.duderino.injection.jmockit._6.Class.Dependency has private access in org.duderino.injection.jmockit._6.Class
[ERROR] /Users/blattj/dev/injection/src/test/java/org/duderino/injection/jmockit/_6/ClassTest.cs:[22,30] org.duderino.injection.jmockit._6.Class.Dependency has private access in org.duderino.injection.jmockit._6.Class
[INFO] 2 errors 

<br></pre>The same results were observed by omitting the 'static' qualifier.<br>
    <h2>7. Inject a mock that delegates to a real instance</h2>
    Since we want to make sure we call the real dependency, we first change it
    to return a constant rather than the random number used in previous
    examples.&nbsp;&nbsp; Our test case will assert later that this constant was
    in fact returned.<br>
    <br>
    Dependency.cs:<br>
    <pre>public class Dependency {
    public int generate() {
        return 123;
    }
}
</pre>
    And the class under test instantiates and calls the dependency as usual.<br>
    <br>
    Class.cs:<br>
    <pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}
<br></pre>
    So we save all the complexity for the test case...<br>
    <br>
    ClassTest.cs:<br>
    <pre>public class ClassTest {
    @Test
    public void testIt() {
        final List&lt;Integer&gt; calls = new ArrayList&lt;Integer&gt;();

        Mockit.setUpMock(Dependency.class, new Dependency() {
            //private int numCalls = 0;
            public Dependency it;

            @Mock(reentrant = true)
            @Override
            public int generate() {
                int result = it.generate();

                calls.add(new Integer(result));

                return result;
            }
        });

        Class clazz = new Class();

        for (int i = 0; i &lt; 10; ++i) {
            assert 123 * 2 == clazz.generate();
        }

        assert calls.size() == 10;
    }
}</pre>
    Several special things have to happen when we setup this mock object.<br>
    <br>
    We have to declare a 'public Dependency it;' member.&nbsp;&nbsp; All three
    tokens are important here.&nbsp;&nbsp; If the member is declared private,
    JMockit will throw an exception that looks like this:<br>
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 7, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.529 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._7.ClassTest)  Time elapsed: 0.012 sec  &lt;&lt;&lt; FAILURE!
java.lang.IllegalAccessError: tried to access field org.duderino.injection.jmockit._7.ClassTest$1.it from class org.duderino.injection.jmockit._7.Dependency
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.cs)
	at org.duderino.injection.jmockit._7.Class.generate(Class.cs:10)
	at org.duderino.injection.jmockit._7.ClassTest.testIt(ClassTest.cs:37)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._7.ClassTest): tried to access field org.duderino.injection.jmockit._7.ClassTest$1.it from class org.duderino.injection.jmockit._7.Dependency

Tests run: 7, Failures: 1, Errors: 0, Skipped: 0
<br></pre>Assuming there is a publicly accessible 'it' member with the same type
    as the real, non-mocked instance, JMockit will automatically copy the real,
    non-mocked instance reference into the 'it' attribute.&nbsp;&nbsp; While not
    tested, getting the data type wrong would probably produced a
    ClassCastException.<br>
    <br>
    The other special gotcha is the 'reentrant = true' qualifier on the @Mock
    annotation.&nbsp;&nbsp; Without this qualifier JMockit will still redirect
    calls to the real instance to the mock.&nbsp;&nbsp; That is, the mock will
    call itself recursively, generating a stack overflow that looks like this:<br>
    <br>
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 7, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.668 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._7.ClassTest)  Time elapsed: 0.095 sec  &lt;&lt;&lt; FAILURE!
java.lang.StackOverflowError
	at java.util.HashMap.get(HashMap.cs:298)
	at java.util.Collections$SynchronizedMap.get(Collections.cs:1975)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.cs)
	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.cs:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.cs)
	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.cs:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.cs)
<br>...<br>	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.cs:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.cs)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._7.ClassTest)

Tests run: 7, Failures: 1, Errors: 0, Skipped: 0
<br></pre>
    <h2>8. Inject hand-coded mocks or stubs </h2>
    Well, this one is kinda a 'duh'.&nbsp; Every example so far has injected a
    hand-coded mock. <br>
    <h2>9. Mocks injection can be narrowly targeted</h2>
    <br>
    <h3>Lesson Learned: Mocking Out The Java Class Library Is Dangerous</h3>
    Configuration.cs<br>
    <pre>package org.duderino.injection.jmockit._1;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.FileInputStream;
import java.util.HashMap;
import java.util.Map;

public class Configuration {
    private Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    private final String path;

    public Configuration(String path) throws Exception {
        this.path = path;

        reload();
    }

    public String get(String key) {
        return map.get(key);
    }

    public void reload() throws Exception {
        map.clear();

        DocumentBuilder docBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();

        Document document = docBuilder.parse(new FileInputStream(path));

        NodeList settings = document.getElementsByTagName("setting");

        for (int i = 0; i &lt; settings.getLength(); ++i) {
            Node setting = settings.item(i);

            NodeList children = setting.getChildNodes();

            String key = null;
            String value = null;

            for (int j = 0; j &lt; children.getLength(); ++j) {
                Node child = children.item(j);

                if ("key".equals(child.getNodeName())) {
                    key = child.getNodeValue();
                    continue;
                }

                if ("value".equals(child.getNodeName())) {
                    value = child.getNodeValue();
                    continue;
                }
            }

            if (null != key) {
                map.put(key, value);
            }
        }
    }
}
<br></pre>
    ConfigurationTest.cs<br>
    <pre>package org.duderino.injection.jmockit._1;

import mockit.Mock;
import mockit.Mockit;
import org.testng.annotations.Test;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

public class ConfigurationTest {
    @Test
    public void testCheck() throws Exception {
        final String xml = "&lt;settings&gt;&lt;setting&gt;&lt;key&gt;foo&lt;/key&gt;&lt;value&gt;bar&lt;/value&gt;&lt;/setting&gt;&lt;/settings&gt;";

        Mockit.setUpMock(FileInputStream.class, new InputStream() {
            private byte[] bytes = xml.getBytes("UTF-8");
            private int index = 0;

            @Mock
            public int read() throws IOException {
                if (index &gt;= bytes.length) {
                    return 0;
                }

                return bytes[index++];
            }

            @Mock
            private void open(String name) throws FileNotFoundException {
                // do nothing
            }
        });

        Configuration configuration = new Configuration("dummy path");

        assert "bar".equals(configuration.get("foo"));
    }
}
<br></pre>
    Output:<br>
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running TestSuite
WARNING: JMockit was initialized on demand, which may cause certain tests to fail;
please check the documentation for better ways to get it initialized.
ZoneInfo: Bad file descriptor
ZoneInfo: Bad file descriptor
ZoneInfo: Bad file descriptor
Tests run: 2, Failures: 2, Errors: 0, Skipped: 0, Time elapsed: 0.779 sec &lt;&lt;&lt; FAILURE!
testCheck(org.duderino.injection.jmockit._1.ConfigurationTest)  Time elapsed: 0.382 sec  &lt;&lt;&lt; FAILURE!
java.lang.NoClassDefFoundError: org/duderino/injection/jmockit/_1/Configuration
	at org.duderino.injection.jmockit._1.ConfigurationTest.testCheck(ConfigurationTest.cs:36)
Caused by: java.lang.ClassNotFoundException: org.duderino.injection.jmockit._1.Configuration
	at java.net.URLClassLoader$1.run(URLClassLoader.cs:199)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.cs:190)
	at java.lang.ClassLoader.loadClass(ClassLoader.cs:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.cs:301)
	at java.lang.ClassLoader.loadClass(ClassLoader.cs:247)
	... 35 more
Caused by: java.io.IOException: Bad file descriptor
	at java.io.FileInputStream.readBytes(Native Method)
	at java.io.FileInputStream.read(FileInputStream.cs:220)
	at sun.misc.Resource.getBytes(Resource.cs:108)
	at java.net.URLClassLoader.defineClass(URLClassLoader.cs:257)
	at java.net.URLClassLoader.access$000(URLClassLoader.cs:58)
	at java.net.URLClassLoader$1.run(URLClassLoader.cs:197)
	... 40 more
testCheck(org.duderino.injection.jmockit.basic.Y2KCheckerTest)  Time elapsed: 0.01 sec  &lt;&lt;&lt; FAILURE!
<br></pre>
    <br>
    <h2>10. Generate basic stubs </h2>
    <h2>11. Generate basic mocks</h2>
    <h2>12. Generate async-friendly mocks</h2>
    <h2>13. Generate thread-friendly mocks</h2>
    <h2>14. Associate assertions in hand-coded mocks or stubs with test cases in
      same thread</h2>
    <h2>15. Associate assertions in hand-coded mocks or stubs with test cases in
      different thread</h2>
    <br>
    <br>
    <br>
    <br>
    <h1> <br>
    </h1>
  </body>
</html>
