<html>
  <head>
    <title>Moles Evaluation</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  </head>
  <body>
    <h1>Moles Evaluation</h1>
    <p>See&nbsp;<a href="https://github.com/duderino/injection/tree/master/MolesTest">https://github.com/duderino/injection/tree/master/MolesTest</a>
      for complete source code.<br>
    </p>
    <p> </p>
    <h2>1. Inject mocks/stubs without changing the API</h2>
    Class.cs:<br>
    <pre>    public class Class01
    {
        private Dependency01 dependency = new Dependency01();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }
<br></pre> Dependency.cs:<br>
    <pre>    public class Dependency01
    {
        public virtual int generate()
        {
            return 999;
        }
    }<br></pre>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest01
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MDependency01.AllInstances.generate = _ =&gt; 123;
            
            Class01 clazz = new Class01();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }<br></pre>
    <h2>2. Mock/stub out final/non-virtual functions</h2>
    Class.cs:<br>
    <pre>    public class Class02
    {
        private Dependency02 dependency = new Dependency02();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }
<br></pre>Removed virtual keyword from generate method and made the class sealed
    <br>
    <br>
    Dependency.cs:<br>
    <pre>    public sealed class Dependency02
    {
        public int generate()
        {
            return 999;
        }
    }<br><br></pre>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest02
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MDependency02.AllInstances.generate = _ =&gt; 123;
            
            Class02 clazz = new Class02();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }<br></pre>
    <h2>3. Mock/stub out static functions</h2>
    Here we change our dependency's method to be static.<br>
    <br>
    Dependency.cs:<br>
    <pre>    public static class Dependency03
    {
        public static int generate()
        {
            return 999;
        }
    }
</pre> The class under test no longer instantiates the dependency and instead
    calls its static method.<br>
    <br>
    Class.cs:<br>
    <pre>    public class Class03
    {
        public int generate()
        {
            return Dependency03.generate() * 2;
        }
    }
<br></pre>The static method can be mocked using the MDependency03.generate
    delegate.&nbsp;&nbsp; Use of the AllInstances inner class is not required
    for mocking out static functions.<br>
    <br>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest03
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MDependency03.generate = () =&gt; 123;
            
            Class03 clazz = new Class03();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }</pre>
    <h2>4. Mock/stub out constructors</h2>
    Here we change our dependency to take an argument in its constructor.<br>
    <br>
    Dependency.cs:<br>
    <pre>    public class Dependency04
    {
        private int value;

        public Dependency04(int value)
        {
            this.value = value;
        }

        public int generate()
        {
            return value;
        }
    }
</pre><br>
    <br>
    Class.cs:<br>
    <pre>    public class Class04
    {
        private Dependency04 dependency = new Dependency04(999);

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }
<br></pre>TODO - assert on values passed to ctor.&nbsp;&nbsp; can also
    dynamically modify mock in its ctor.<br>
    <br>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest04
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MDependency04.ConstructorInt32 = (@this, value) =&gt; { 
                Assert.AreEqual(999, value);

                var mole = new MDependency04(@this) { generate = () =&gt; 123 }; 
            };
            
            Class04 clazz = new Class04();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }
</pre>
    <h2>5. Mock/stub out anonymous inner/nested classes</h2>
    This is not applicable to C#.&nbsp;&nbsp; While C# has anonymous classes,
    they cannot implement an interface but are instead limited to a collection
    of simple, read-only properties.&nbsp;&nbsp; This class to test, for
    instance, is so contrived it's not very useful.&nbsp;&nbsp; The anonymous
    class is really a hard-coded constant and not a true dependency.<br>
    <pre>    public class Class05
    {
        public int generate()
        {
            var dependency = new { generate = 999 };

            return dependency.generate * 2;
        }
    }<br></pre>
    <h2>6. Mock/stub out inaccessible (e.g., private) inner/nested classes</h2>
    For this test we moved the Dependency class into the Class class.<br>
    <br>
    Class.cs:<br>
    <pre>    public class Class06
    {
        private class Dependency06
        {
            public int generate()
            {
                return 999;
            }
        }

        private Dependency06 dependency = new Dependency06();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }<br></pre>
    <br>
    <br>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest04
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            MClass06.MDependency06.AllInstances.generate = _ =&gt; 123;

            Class06 clazz = new Class06();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }

</pre> The result was a compilation error:<br>
    <pre>------ Build started: Project: MolesTest, Configuration: Debug Any CPU ------
  MolesTest -&gt; C:\Users\foo\Documents\Visual Studio 2010\Projects\MolesTest\MolesTest\bin\Debug\MolesTest.dll
------ Build started: Project: MolesTest.Tests, Configuration: Debug Any CPU ------
C:\Users\foo\Documents\Visual Studio 2010\Projects\MolesTest\MolesTest.Tests05\_6\ClassTest06.cs(22,22): error CS0117: 'MolesTest._6.Moles.MClass06' does not contain a definition for 'MDependency06'

Compile complete -- 1 errors, 0 warnings
  Microsoft Moles v0.94.51006.1 - http://research.microsoft.com/moles - .NET v4.0.30319
  Copyright (c) Microsoft Corporation 2007-2010. All rights reserved.
  
  Generating 2 Moles assemblies with 2 concurrent processes
  3:start&gt; MolesTest.moles
  4:start&gt; mscorlib.moles
  4:end&gt; mscorlib.moles Success (0 - 0x0)
  3:end&gt; MolesTest.moles Success (0 - 0x0)
  
  	Moles compilation SUCCESS - 2.5885226s
========== Build: 1 succeeded or up-to-date, 1 failed, 0 skipped ==========
<br></pre>The same test works if the accessibility of the Dependency06 class is
    changed from private to public.&nbsp;&nbsp; We also tried making the
    internals visible to Moles by adding these two lines to the assembly, but
    they did not help:<br>
    <pre>[assembly: InternalsVisibleTo("MolesTest._6.Moles")]
[assembly: InternalsVisibleTo("MolesTest.Moles")]<br></pre>
    <h2>7. Mock/stub out subclass and superclass functions</h2>
    <p>SuperDepenency.cs:<br>
    </p>
    <pre>    public class SuperDependency07
    {
        public virtual int generate()
        {
            return 999;
        }

        public int superGenerate()
        {
            return 999;
        }
    }<br></pre>
    SubDependency.cs:<br>
    <pre>    public class SubDependency07 : SuperDependency07
    {
        public override int generate()
        {
            return 333;
        }

        public int subGenerate()
        {
            return 333;
        }
    }<br></pre>
    Class.cs:<br>
    <pre>    public class Class07
    {
        private SubDependency07 dependency = new SubDependency07();

        public int generate()
        {
            return 2 * dependency.generate();
        }

        public int superGenerate()
        {
            return 2 * dependency.superGenerate();
        }

        public int subGenerate()
        {
            return 2 * dependency.subGenerate();
        }
    }<br></pre>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest07
    {
        [TestMethod]
        [HostType("Moles")]
        public void testOverride()
        {
            MSubDependency07.AllInstances.generate = _ =&gt; 123;

            Class07 clazz = new Class07();

            Assert.AreEqual(2 * 123, clazz.generate());
            Assert.AreEqual(2 * 333, clazz.subGenerate());
            Assert.AreEqual(2 * 999, clazz.superGenerate());
        }

        [TestMethod]
        [HostType("Moles")]
        public void testOvershadow()
        {
            MSuperDependency07.AllInstances.generate = _ =&gt; 123;

            Class07 clazz = new Class07();

            Assert.AreEqual(2 * 333, clazz.generate());
            Assert.AreEqual(2 * 333, clazz.subGenerate());
            Assert.AreEqual(2 * 999, clazz.superGenerate());
        }

        [TestMethod]
        [HostType("Moles")]
        public void testSuper()
        {
            // does not compile: MSubDependency07.AllInstances.superGenerate = _ =&gt; 123;

            MSuperDependency07.AllInstances.superGenerate = _ =&gt; 123;

            Class07 clazz = new Class07();

            Assert.AreEqual(2 * 333, clazz.generate());
            Assert.AreEqual(2 * 333, clazz.subGenerate());
            Assert.AreEqual(2 * 123, clazz.superGenerate());
        }

        [TestMethod]
        [HostType("Moles")]
        public void testSub()
        {
            MSubDependency07.AllInstances.subGenerate = _ =&gt; 123;

            Class07 clazz = new Class07();

            Assert.AreEqual(2 * 333, clazz.generate());
            Assert.AreEqual(2 * 123, clazz.subGenerate());
            Assert.AreEqual(2 * 999, clazz.superGenerate());
        }
    }<br></pre>
    <pre></pre>
    <h2>8. Inject a mock that delegates to a real instance</h2>
    Dependency.java:<br>
    <pre>    public class Dependency08
    {
        public int generate()
        {
            return 999;
        }
    }
</pre> <br>
    Class.java:<br>
    <pre>    public class Class08
    {
        private Dependency08 dependency = new Dependency08();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }
<br></pre> So we save all the complexity for the test case...<br>
    <br>
    ClassTest.java:<br>
    <pre>    [TestClass]
    public class ClassTest01
    {
        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            int count = 0;

            MDependency08.AllInstances.generate = (Dependency08 dependency) =&gt;
            {
                ++count;

                return MolesContext.ExecuteWithoutMoles(() =&gt; {
                    return dependency.generate();
                });
            };
            
            Class08 clazz = new Class08();

            for (int i = 0; i &lt; 10; ++i)
            {
                Assert.AreEqual(2 * 999, clazz.generate());
            }

            Assert.AreEqual(10, count);
        }
    }</pre>
    <br>
    <h2>9. Inject hand-coded mocks or stubs </h2>
    Dependency.cs:<br>
    <pre>    public class Dependency09
    {
        public int generate()
        {
            return 999;
        }
    }<br></pre>
    Class.cs:<br>
    <pre>    public class Class09
    {
        private Dependency09 dependency = new Dependency09();

        public int generate()
        {
            return dependency.generate() * 2;
        }
    }<br></pre>
    ClassTest.cs:<br>
    <pre>    [TestClass]
    public class ClassTest09
    {
        private class MockDependency
        {
            private int value = 123;

            public int generate()
            {
                return value;
            }
        }

        [TestMethod]
        [HostType("Moles")]
        public void test()
        {
            // While this works, it doesn't appear to be threadsafe.

            MockDependency mockDependency = new MockDependency();

            MDependency09.AllInstances.generate = _ =&gt;
            {
                return mockDependency.generate();
            };
            
            Class09 clazz = new Class09();

            Assert.AreEqual(2 * 123, clazz.generate());
        }
    }<br></pre>
    <h2>10. Mocks injection can be narrowly targeted</h2>
    <br>
    <h3>Lesson Learned: Mocking Out The Java Class Library Is Dangerous</h3>
    Configuration.java<br>
    <pre>package org.duderino.injection.jmockit._1;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.FileInputStream;
import java.util.HashMap;
import java.util.Map;

public class Configuration {
    private Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    private final String path;

    public Configuration(String path) throws Exception {
        this.path = path;

        reload();
    }

    public String get(String key) {
        return map.get(key);
    }

    public void reload() throws Exception {
        map.clear();

        DocumentBuilder docBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();

        Document document = docBuilder.parse(new FileInputStream(path));

        NodeList settings = document.getElementsByTagName("setting");

        for (int i = 0; i &lt; settings.getLength(); ++i) {
            Node setting = settings.item(i);

            NodeList children = setting.getChildNodes();

            String key = null;
            String value = null;

            for (int j = 0; j &lt; children.getLength(); ++j) {
                Node child = children.item(j);

                if ("key".equals(child.getNodeName())) {
                    key = child.getNodeValue();
                    continue;
                }

                if ("value".equals(child.getNodeName())) {
                    value = child.getNodeValue();
                    continue;
                }
            }

            if (null != key) {
                map.put(key, value);
            }
        }
    }
}
<br></pre> ConfigurationTest.java<br>
    <pre>package org.duderino.injection.jmockit._1;

import mockit.Mock;
import mockit.Mockit;
import org.testng.annotations.Test;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

public class ConfigurationTest {
    @Test
    public void testCheck() throws Exception {
        final String xml = "&lt;settings&gt;&lt;setting&gt;&lt;key&gt;foo&lt;/key&gt;&lt;value&gt;bar&lt;/value&gt;&lt;/setting&gt;&lt;/settings&gt;";

        Mockit.setUpMock(FileInputStream.class, new InputStream() {
            private byte[] bytes = xml.getBytes("UTF-8");
            private int index = 0;

            @Mock
            public int read() throws IOException {
                if (index &gt;= bytes.length) {
                    return 0;
                }

                return bytes[index++];
            }

            @Mock
            private void open(String name) throws FileNotFoundException {
                // do nothing
            }
        });

        Configuration configuration = new Configuration("dummy path");

        assert "bar".equals(configuration.get("foo"));
    }
}
<br></pre> Output:<br>
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running TestSuite
WARNING: JMockit was initialized on demand, which may cause certain tests to fail;
please check the documentation for better ways to get it initialized.
ZoneInfo: Bad file descriptor
ZoneInfo: Bad file descriptor
ZoneInfo: Bad file descriptor
Tests run: 2, Failures: 2, Errors: 0, Skipped: 0, Time elapsed: 0.779 sec &lt;&lt;&lt; FAILURE!
testCheck(org.duderino.injection.jmockit._1.ConfigurationTest)  Time elapsed: 0.382 sec  &lt;&lt;&lt; FAILURE!
java.lang.NoClassDefFoundError: org/duderino/injection/jmockit/_1/Configuration
	at org.duderino.injection.jmockit._1.ConfigurationTest.testCheck(ConfigurationTest.java:36)
Caused by: java.lang.ClassNotFoundException: org.duderino.injection.jmockit._1.Configuration
	at java.net.URLClassLoader$1.run(URLClassLoader.java:199)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
	... 35 more
Caused by: java.io.IOException: Bad file descriptor
	at java.io.FileInputStream.readBytes(Native Method)
	at java.io.FileInputStream.read(FileInputStream.java:220)
	at sun.misc.Resource.getBytes(Resource.java:108)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:257)
	at java.net.URLClassLoader.access$000(URLClassLoader.java:58)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:197)
	... 40 more
testCheck(org.duderino.injection.jmockit.basic.Y2KCheckerTest)  Time elapsed: 0.01 sec  &lt;&lt;&lt; FAILURE!
<br></pre> <br>
    <h2>11. Generate basic stubs </h2>
    <h2>12. Generate basic mocks</h2>
    <h2>13. Generate async-friendly mocks</h2>
    <h2>14. Generate thread-friendly mocks</h2>
    <h2>15. Associate assertions in hand-coded mocks or stubs with test cases in
      same thread</h2>
    <h2>16. Associate assertions in hand-coded mocks or stubs with test cases in
      different thread</h2>
    <br>
  </body>
</html>
