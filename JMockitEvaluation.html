<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <title>JMockit Evaluation</title>
  </head>
  <body>
    <h1>JMockit Evaluation</h1>
    <p>See <a href="https://github.com/duderino/injection">https://github.com/duderino/injection</a>
      for complete source code.<br />
    </p>
    <h2>1. Inject mocks/stubs without changing the API</h2>
    <p>TODO - replace all random number generation with return 999;</p>
    Class.java:<br />
    <pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}<br /></pre>
    Dependency.java:<br />
    <pre>public class Dependency {
    public int generate() {
        return (int) Math.random() * 1000;
    }
}<br /></pre>
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, new Dependency() {
            @Mock
            @Override
            public int generate() {
                return 123;
            }
        });

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /><br /></pre>
    TODO - mention must setUpMock for the exact class the method was declared
    in, not the immediate class.<br />
    <h2>2. Mock/stub out final/non-virtual functions</h2>
    Change dependency to be final so our mock cannot subclass it.<br />
    <br />
    Dependency.java:<br />
    <pre>public final class Dependency {
    public final int generate() {
        return (int) Math.random() * 1000;
    }
}</pre>
    The class under test doesn't change.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}
<br /></pre> The test case can no longer use Java's anonymous inner class
    mechanism since the dependency cannot be subclassed.   Instead it has to use
    a static/regular class with JMockit's @MockClass annotation.   The
    annotation tells JMockit which class the mock is meant to replace.   It
    works, but it is a bit less natural.<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        public int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /></pre>
    JMockit also supports an alternative mechanism for these cases via its
    MockUp generic class.   The authors recommend this as a replacement for the
    convenience of anonymous mock classes, but the approach is arguably more
    obscure.<br />
    <br />
    ClassTestAlternative.java:<br />
    <pre>public class ClassTestAlternative {
    @Test
    public void testIt() {
        new MockUp&lt;Dependency&gt;() {
            @Mock
            public int generate() {
                return 123;
            }
        };


        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /></pre>
    <h2>3. Mock/stub out static functions</h2>
    Here we change our dependency's method to be static.<br />
    <br />
    Dependency.java:<br />
    <pre>public class Dependency {
    public static int generate() {
        return (int) Math.random() * 1000;
    }
}
</pre> The class under test no longer instantiates the dependency and instead
    calls its static method.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    public int generate() {
        return Dependency.generate() * 2;
    }
}
<br /></pre> The static method can be mocked out using the same mechanism used
    in the previous example.<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        public static int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}</pre>
    <h2>4. Mock/stub out constructors</h2>
    Here we change our dependency to take an argument in its constructor.<br />
    <br />
    Dependency.java:<br />
    <pre>public class Dependency {
    private final int max;

    public Dependency(int max) {
        this.max = max;
    }

    public int generate() {
        return (int) Math.random() * max;
    }
}
</pre> The class under test is similarly modified to pass the argument through
    its constructor to the dependency's constructor.<br />
    <br />
    TODO - bring up to date with moles equivalent.   Class should pass hardcoded
    999 to Dependency.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    private final Dependency dependency;

    public Class(int max) {
        dependency = new Dependency(max);
    }

    public int generate() {
        return dependency.generate() * 2;
    }
}
<br /></pre> Finally the test case is modified to pass the argument to the
    constructor.   By defining a special "void $init()" method, the mock can
    verify that the constructor was passed the correct value.<br />
    <br />
    TODO - can you change anything in the ctor?<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    private static final int MAX = 1000;

    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        void $init(int max) {
            assert MAX == max;
        }

        @Mock
        public static int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class(MAX);

        assert 123 * 2 == clazz.generate();
    }
}
</pre>
    <h2>5. Mock/stub out anonymous inner classes</h2>
    Sometimes the class under test creates an anonymous inner class that we'd
    like to mock out.   This is a particularly hard problem because the inner
    class may call back on the class under test's internals.<br />
    <br />
    Either JMockit does not support this or I simply couldn't figure out how to
    do it.   This is what I tried to do...<br />
    <br />
    First, I turned the Dependency into an interface.<br />
    <br />
    Dependency.java:<br />
    <pre>public interface Dependency {
    int generate();
}
</pre> Next I modified the class under test to instantiate an anonymous
    implementation of the interface.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    public int generate() {
       Dependency dependency = new Dependency() {
           @Override
           public int generate() {
               return (int) Math.random() * 1000;
           }
       };

        return dependency.generate() * 2;
    }
}<br /></pre>
    Finally the test case was modified to inject a mock version of the
    Dependency.<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        public int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}
</pre> Unfortunately JMockit threw a "Not a modifiable class"
    IllegalArgumentException when the test was run:<br />
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 1, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.42 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._5.ClassTest)  Time elapsed: 0.033 sec  &lt;&lt;&lt; FAILURE!
java.lang.IllegalArgumentException: Not a modifiable class: org.duderino.injection.jmockit._5.Dependency
	at org.duderino.injection.jmockit._5.ClassTest.testIt(ClassTest.java:22)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._5.ClassTest): Not a modifiable class: org.duderino.injection.jmockit._5.Dependency

Tests run: 1, Failures: 1, Errors: 0, Skipped: 0
<br /></pre>
    <h2>6. Mock/stub out inaccessible (e.g., private) inner classes</h2>
    Extending on the previous example, it appears that JMockit must have access
    to the definition of every class it needs to mock out.   Private inner
    classes, static or not, are not visible to the JMockit annotations so they
    break compilation.<br />
    <br />
    For this test we moved the Dependency class into the Class class.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    private static class Dependency {
        public int generate() {
            return (int) Math.random() * 1000;
        }
    }

    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}<br /></pre>
    Next we tried to inject a mock implementation in the test case.<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @MockClass(realClass = Class.Dependency.class)
    public static class MockDependency {
        @Mock
        public int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Class.Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}

</pre> The result was a predictable compilation error:<br />
    <pre>[INFO] -------------------------------------------------------------
[ERROR] COMPILATION ERROR : 
[INFO] -------------------------------------------------------------
[ERROR] /Users/blattj/dev/injection/src/test/java/org/duderino/injection/jmockit/_6/ClassTest.java:[12,32] org.duderino.injection.jmockit._6.Class.Dependency has private access in org.duderino.injection.jmockit._6.Class
[ERROR] /Users/blattj/dev/injection/src/test/java/org/duderino/injection/jmockit/_6/ClassTest.java:[22,30] org.duderino.injection.jmockit._6.Class.Dependency has private access in org.duderino.injection.jmockit._6.Class
[INFO] 2 errors 

<br /></pre> The same results were observed by omitting the 'static' qualifier.<br />
    <h2>7. Mock/stub out subclass and superclass functions</h2>
    <p>TODO - mock out 1 method in superclass and 1 method in subclass.   Might
      be an exclusive OR.<br />
    </p>
    <h2>8. Inject a mock that delegates to a real instance</h2>
    <p>TODO - rename these in source code from here down - add 1 to package.<br />
    </p>
    Since we want to make sure we call the real dependency, we first change it
    to return a constant rather than the random number used in previous
    examples.   Our test case will assert later that this constant was in fact
    returned.<br />
    <br />
    Dependency.java:<br />
    <pre>public class Dependency {
    public int generate() {
        return 123;
    }
}
</pre> And the class under test instantiates and calls the dependency as usual.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}
<br /></pre> So we save all the complexity for the test case...<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @Test
    public void testIt() {
        final List&lt;Integer&gt; calls = new ArrayList&lt;Integer&gt;();

        Mockit.setUpMock(Dependency.class, new Dependency() {
            //private int numCalls = 0;
            public Dependency it;

            @Mock(reentrant = true)
            @Override
            public int generate() {
                int result = it.generate();

                calls.add(new Integer(result));

                return result;
            }
        });

        Class clazz = new Class();

        for (int i = 0; i &lt; 10; ++i) {
            assert 123 * 2 == clazz.generate();
        }

        assert calls.size() == 10;
    }
}</pre>
    Several special things have to happen when we setup this mock object.<br />
    <br />
    We have to declare a 'public Dependency it;' member.   All three tokens are
    important here.   If the member is declared private, JMockit will throw an
    exception that looks like this:<br />
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 7, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.529 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._7.ClassTest)  Time elapsed: 0.012 sec  &lt;&lt;&lt; FAILURE!
java.lang.IllegalAccessError: tried to access field org.duderino.injection.jmockit._7.ClassTest$1.it from class org.duderino.injection.jmockit._7.Dependency
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
	at org.duderino.injection.jmockit._7.Class.generate(Class.java:10)
	at org.duderino.injection.jmockit._7.ClassTest.testIt(ClassTest.java:37)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._7.ClassTest): tried to access field org.duderino.injection.jmockit._7.ClassTest$1.it from class org.duderino.injection.jmockit._7.Dependency

Tests run: 7, Failures: 1, Errors: 0, Skipped: 0
<br /></pre> Assuming there is a publicly accessible 'it' member with the same
    type as the real, non-mocked instance, JMockit will automatically copy the
    real, non-mocked instance reference into the 'it' attribute.   While not
    tested, getting the data type wrong would probably produced a
    ClassCastException.<br />
    <br />
    The other special gotcha is the 'reentrant = true' qualifier on the @Mock
    annotation.   Without this qualifier JMockit will still redirect calls to
    the real instance to the mock.   That is, the mock will call itself
    recursively, generating a stack overflow that looks like this:<br />
    <br />
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 7, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.668 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._7.ClassTest)  Time elapsed: 0.095 sec  &lt;&lt;&lt; FAILURE!
java.lang.StackOverflowError
	at java.util.HashMap.get(HashMap.java:298)
	at java.util.Collections$SynchronizedMap.get(Collections.java:1975)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.java:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.java:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
<br />...<br />	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.java:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._7.ClassTest)

Tests run: 7, Failures: 1, Errors: 0, Skipped: 0
<br /></pre>
    <h2>9. Inject hand-coded mocks or stubs </h2>
    Well, this one is kinda a 'duh'.  Every example so far has injected a
    hand-coded mock. <br />
    <h2>10. Mock/stub injection can be toggled</h2>
    <h2>11. Mock/stub injection can be narrowly targeted</h2>
    <h2>12. Mock/stub out any implementation of an interface</h2>
    <p>TODO - use case - dependency injection frameworks where the
      implementation of an interface is not known in advance and the code under
      test only knows of the interface.</p>
    <p></p>
    <h2>13. Safely mock/stub out class library</h2>
    <p>Can core classes in the class library be safely mocked out without
      interfering with the virtual machine?<br />
    </p>
    <p>Configuration.java<br />
    </p>
    <pre>package org.duderino.injection.jmockit._1;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.FileInputStream;
import java.util.HashMap;
import java.util.Map;

public class Configuration {
    private Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    private final String path;

    public Configuration(String path) throws Exception {
        this.path = path;

        reload();
    }

    public String get(String key) {
        return map.get(key);
    }

    public void reload() throws Exception {
        map.clear();

        DocumentBuilder docBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();

        Document document = docBuilder.parse(new FileInputStream(path));

        NodeList settings = document.getElementsByTagName("setting");

        for (int i = 0; i &lt; settings.getLength(); ++i) {
            Node setting = settings.item(i);

            NodeList children = setting.getChildNodes();

            String key = null;
            String value = null;

            for (int j = 0; j &lt; children.getLength(); ++j) {
                Node child = children.item(j);

                if ("key".equals(child.getNodeName())) {
                    key = child.getNodeValue();
                    continue;
                }

                if ("value".equals(child.getNodeName())) {
                    value = child.getNodeValue();
                    continue;
                }
            }

            if (null != key) {
                map.put(key, value);
            }
        }
    }
}
<br /></pre> ConfigurationTest.java<br />
    <pre>package org.duderino.injection.jmockit._1;

import mockit.Mock;
import mockit.Mockit;
import org.testng.annotations.Test;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

public class ConfigurationTest {
    @Test
    public void testCheck() throws Exception {
        final String xml = "&lt;settings&gt;&lt;setting&gt;&lt;key&gt;foo&lt;/key&gt;&lt;value&gt;bar&lt;/value&gt;&lt;/setting&gt;&lt;/settings&gt;";

        Mockit.setUpMock(FileInputStream.class, new InputStream() {
            private byte[] bytes = xml.getBytes("UTF-8");
            private int index = 0;

            @Mock
            public int read() throws IOException {
                if (index &gt;= bytes.length) {
                    return 0;
                }

                return bytes[index++];
            }

            @Mock
            private void open(String name) throws FileNotFoundException {
                // do nothing
            }
        });

        Configuration configuration = new Configuration("dummy path");

        assert "bar".equals(configuration.get("foo"));
    }
}
<br /></pre> Output:<br />
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running TestSuite
WARNING: JMockit was initialized on demand, which may cause certain tests to fail;
please check the documentation for better ways to get it initialized.
ZoneInfo: Bad file descriptor
ZoneInfo: Bad file descriptor
ZoneInfo: Bad file descriptor
Tests run: 2, Failures: 2, Errors: 0, Skipped: 0, Time elapsed: 0.779 sec &lt;&lt;&lt; FAILURE!
testCheck(org.duderino.injection.jmockit._1.ConfigurationTest)  Time elapsed: 0.382 sec  &lt;&lt;&lt; FAILURE!
java.lang.NoClassDefFoundError: org/duderino/injection/jmockit/_1/Configuration
	at org.duderino.injection.jmockit._1.ConfigurationTest.testCheck(ConfigurationTest.java:36)
Caused by: java.lang.ClassNotFoundException: org.duderino.injection.jmockit._1.Configuration
	at java.net.URLClassLoader$1.run(URLClassLoader.java:199)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
	... 35 more
Caused by: java.io.IOException: Bad file descriptor
	at java.io.FileInputStream.readBytes(Native Method)
	at java.io.FileInputStream.read(FileInputStream.java:220)
	at sun.misc.Resource.getBytes(Resource.java:108)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:257)
	at java.net.URLClassLoader.access$000(URLClassLoader.java:58)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:197)
	... 40 more
testCheck(org.duderino.injection.jmockit.basic.Y2KCheckerTest)  Time elapsed: 0.01 sec  &lt;&lt;&lt; FAILURE!
</pre>
    <h2>14. Inject async-friendly mocks/stubs. </h2>
    <h2>15. Inject thread-friendly mocks/stubs.</h2>
    <h2>16. Associate assertions in hand-coded mocks or stubs with test cases in
      same thread</h2>
    <h2>17. Associate assertions in hand-coded mocks or stubs with test cases in
      different thread</h2>
    <br />
    <br />
  </body>
</html>
