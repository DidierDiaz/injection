<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type" />
    <title>JMockit Evaluation</title>
  </head>
  <body>
    <h1>JMockit Evaluation</h1>
    <p>See <a href="https://github.com/duderino/injection">https://github.com/duderino/injection</a>
      for complete source code.<br />
    </p>
    <h2>1. Inject mocks/stubs without changing the API</h2>
    <p>Class.java:<br />

    </p><pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}<br /></pre>
    Dependency.java:<br />
    <pre>public class Dependency {
    public int generate() {
        return 999;
    }
}<br /></pre>
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, new Dependency() {
            @Mock
            @Override
            public int generate() {
                return 123;
            }
        });

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /><br /></pre>
    
    <h2>2. Mock/stub out final/non-virtual functions</h2>
    Change dependency to be final so our mock cannot subclass it.<br />
    <br />
    Dependency.java:<br />
    <pre>public final class Dependency {
    public final int generate() {
        return 999;
    }
}</pre>
    The class under test doesn't change.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}
<br /></pre> The test case can no longer use Java's anonymous inner class
    mechanism since the dependency cannot be subclassed.   Instead it has to use
    a static/regular class with JMockit's @MockClass annotation.   The
    annotation tells JMockit which class the mock is meant to replace.   It
    works, but it is a bit less natural.<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        public int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /></pre>
    JMockit also supports an alternative mechanism for these cases via its
    MockUp generic class.   The authors recommend this as a replacement for the
    convenience of anonymous mock classes, but the approach is arguably more
    obscure.<br />
    <br />
    ClassTestAlternative.java:<br />
    <pre>public class ClassTestAlternative {
    @Test
    public void testIt() {
        new MockUp&lt;Dependency&gt;() {
            @Mock
            public int generate() {
                return 123;
            }
        };


        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /></pre>
    <h2>3. Mock/stub out static functions</h2>
    Here we change our dependency's method to be static.<br />
    <br />
    Dependency.java:<br />
    <pre>public class Dependency {
    public static int generate() {
        return 999;
    }
}
</pre> The class under test no longer instantiates the dependency and instead
    calls its static method.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    public int generate() {
        return Dependency.generate() * 2;
    }
}
<br /></pre> The static method can be mocked out using the same mechanism used
    in the previous example.<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        public static int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}</pre>
    <h2>4. Mock/stub out constructors</h2>
    Here we change our dependency to take an argument in its constructor.<br />
    <br />
    Dependency.java:<br />
    <pre>public class Dependency {
    private int value;

    public Dependency(int value) {
        this.value = value;
    }

    public int generate() {
        return value;
    }
}
</pre> The class under test is similarly modified to pass the argument through
    its constructor to the dependency's constructor.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    private Dependency dependency = new Dependency(999);

    public int generate() {
        return dependency.generate() * 2;
    }
}
<br /></pre> TODO<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        void $init(int value) {
            assert 999 == value;
        }

        @Mock
        public static int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /></pre>Unlike Moles, JMockit has some ability to modify the object
 in the $init constructor, but it's limited by the accessibility of the 
object's members.   If, for instance, we made the value field public, we
 could change its value in the $init constructor and avoid overriding 
the generate method:<br />
<pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        public Dependency it;

        @Mock
        void $init(int value) {
            assert 999 == value;

            it.value = 123;  // Compiles only if Dependency.value is accessible
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /></pre>
TODO - mention use of Dependency it and relate to section 8.<br />
<h2>5. Mock/stub out anonymous inner classes</h2>
    Sometimes the class under test creates an anonymous inner class that we'd
    like to mock out.   This is a particularly hard problem because the inner
    class may call back on the class under test's internals.<br />
    <br />
    Either JMockit does not support this or I simply couldn't figure out how to
    do it.   This is what I tried to do...<br />
    <br />
    First, I turned the Dependency into an interface.<br />
    <br />
    Dependency.java:<br />
    <pre>public interface Dependency {
    int generate();
}
</pre> Next I modified the class under test to instantiate an anonymous
    implementation of the interface.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    public int generate() {
       Dependency dependency = new Dependency() {
           @Override
           public int generate() {
               return 999;
           }
       };

        return dependency.generate() * 2;
    }
}<br /></pre>
    Finally the test case was modified to inject a mock version of the
    Dependency.<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        public int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}
</pre> Unfortunately JMockit threw a "Not a modifiable class"
    IllegalArgumentException when the test was run:<br />
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 1, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.42 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._5.ClassTest)  Time elapsed: 0.033 sec  &lt;&lt;&lt; FAILURE!
java.lang.IllegalArgumentException: Not a modifiable class: org.duderino.injection.jmockit._5.Dependency
	at org.duderino.injection.jmockit._5.ClassTest.testIt(ClassTest.java:22)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._5.ClassTest): Not a modifiable class: org.duderino.injection.jmockit._5.Dependency

Tests run: 1, Failures: 1, Errors: 0, Skipped: 0
<br /></pre>
    <h2>6. Mock/stub out inaccessible (e.g., private) inner classes</h2>
    Extending on the previous example, it appears that JMockit must have access
    to the definition of every class it needs to mock out.   Private inner
    classes, static or not, are not visible to the JMockit annotations so they
    break compilation.<br />
    <br />
    For this test we moved the Dependency class into the Class class.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    private static class Dependency {
        public int generate() {
            return 999;
        }
    }

    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}<br /></pre>
    Next we tried to inject a mock implementation in the test case.<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @MockClass(realClass = Class.Dependency.class)
    public static class MockDependency {
        @Mock
        public int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Class.Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}

</pre> The result was a predictable compilation error:<br />
    <pre>[INFO] -------------------------------------------------------------
[ERROR] COMPILATION ERROR : 
[INFO] -------------------------------------------------------------
[ERROR] /Users/blattj/dev/injection/src/test/java/org/duderino/injection/jmockit/_6/ClassTest.java:[12,32] org.duderino.injection.jmockit._6.Class.Dependency has private access in org.duderino.injection.jmockit._6.Class
[ERROR] /Users/blattj/dev/injection/src/test/java/org/duderino/injection/jmockit/_6/ClassTest.java:[22,30] org.duderino.injection.jmockit._6.Class.Dependency has private access in org.duderino.injection.jmockit._6.Class
[INFO] 2 errors 

<br /></pre> The same results were observed by omitting the 'static' qualifier.<br />
    <h2>7. Mock/stub out subclass and superclass functions</h2>
    <p>TODO - mock out 1 method in superclass and 1 method in subclass.   Might
      be an exclusive OR.</p>
<pre>public class SuperDependency {
    public int generate() {
        return 999;
    }

    public int superGenerate() {
        return 999;
    }
}<br /></pre>
TODO<br />
<pre>public class SubDependency extends SuperDependency {
    @Override
    public int generate() {
        return 333;
    }

    public int subGenerate() {
        return 333;
    }
}<br /></pre>
TODO<br />
<pre>public class Class {
    private SubDependency dependency = new SubDependency();

    public int generate() {
        return 2 * dependency.generate();
    }

    public int superGenerate() {
        return 2 * dependency.superGenerate();
    }

    public int subGenerate() {
        return 2 * dependency.subGenerate();
    }
}<br /></pre>
TODO<br />
<pre>public class ClassTest {
    @Test
    public void testOverride() {
        Mockit.setUpMock(SubDependency.class, new SubDependency() {
            @Mock
            public int generate() {
                return 123;
            }
        });

        Class clazz = new Class();

        assert 2 * 123 == clazz.generate();
        assert 2 * 333 == clazz.subGenerate();
        assert 2 * 999 == clazz.superGenerate();
    }

    @Test
    public void testOvershadow() {
        Mockit.setUpMock(SuperDependency.class, new SuperDependency() {
            @Mock
            public int generate() {
                return 123;
            }
        });

        Class clazz = new Class();

        assert 2 * 333 == clazz.generate();
        assert 2 * 333 == clazz.subGenerate();
        assert 2 * 999 == clazz.superGenerate();
    }

    @Test
    public void testSuper() {
        Mockit.setUpMock(SuperDependency.class, new SuperDependency() {
            @Mock
            public int superGenerate() {
                return 123;
            }
        });

        Class clazz = new Class();

        assert 2 * 333 == clazz.generate();
        assert 2 * 333 == clazz.subGenerate();
        assert 2 * 123 == clazz.superGenerate();
    }

    @Test
    public void testSub() {
        Mockit.setUpMock(SubDependency.class, new SubDependency() {
            @Mock
            public int subGenerate() {
                return 123;
            }
        });

        Class clazz = new Class();

        assert 2 * 333 == clazz.generate();
        assert 2 * 123 == clazz.subGenerate();
        assert 2 * 999 == clazz.superGenerate();
    }
}<br /></pre>
TODO - note the limitation that mocks must be setUp on the class that 
declared the method!   Relate to Moles which has a similar limitation - 
methods are only generated for methods declared in each class<br />
<pre>    @Test
    public void testSuper() {
        Mockit.setUpMock(SubDependency.class, new SubDependency() {
            @Mock
            public int superGenerate() {
                return 123;
            }
        });

        Class clazz = new Class();

        assert 2 * 333 == clazz.generate();
        assert 2 * 333 == clazz.subGenerate();
        assert 2 * 123 == clazz.superGenerate();
    }<br /></pre>
 TODO - produces:<br />
<pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 11, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.578 sec &lt;&lt;&lt; FAILURE!
testSuper(org.duderino.injection.jmockit._7.ClassTest)  Time elapsed: 0.006 sec  &lt;&lt;&lt; FAILURE!
java.lang.IllegalArgumentException: Matching real methods not found for the following mocks of org.duderino.injection.jmockit._7.ClassTest$3:
int superGenerate()
	at org.duderino.injection.jmockit._7.ClassTest.testSuper(ClassTest.java:43)

Results :

Failed tests:   testSuper(org.duderino.injection.jmockit._7.ClassTest): Matching real methods not found for the following mocks of org.duderino.injection.jmockit._7.ClassTest$3:

Tests run: 11, Failures: 1, Errors: 0, Skipped: 0

<br />
    </pre>

    <h2>8. Inject a mock that delegates to a real instance</h2>TODO<br />
    <br />
    Dependency.java:<br />
    <pre>public class Dependency {
    public int generate() {
        return 999;
    }
}
</pre> And the class under test instantiates and calls the dependency as usual.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}
<br /></pre>TODO<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    private static class Count {
        private int value = 0;

        public void increment() {
            ++value;
        }

        public int total() {
            return value;
        }
    }

    @Test
    public void testIt() {
        final Count count = new Count();

        Mockit.setUpMock(Dependency.class, new Dependency() {
            public Dependency it;

            @Mock(reentrant = true)
            @Override
            public int generate() {
                count.increment();

                return it.generate();
            }
        });

        Class clazz = new Class();

        for (int i = 0; i &lt; 10; ++i) {
            assert 999 * 2 == clazz.generate();
        }

        assert count.total() == 10;
    }
}</pre>
    Several special things have to happen when we setup this mock object.<br />
    <br />
    We have to declare a 'public Dependency it;' member.   All three tokens are
    important here.   If the member is declared private, JMockit will throw an
    exception that looks like this:<br />
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 7, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.529 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._7.ClassTest)  Time elapsed: 0.012 sec  &lt;&lt;&lt; FAILURE!
java.lang.IllegalAccessError: tried to access field org.duderino.injection.jmockit._7.ClassTest$1.it from class org.duderino.injection.jmockit._7.Dependency
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
	at org.duderino.injection.jmockit._7.Class.generate(Class.java:10)
	at org.duderino.injection.jmockit._7.ClassTest.testIt(ClassTest.java:37)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._7.ClassTest): tried to access field org.duderino.injection.jmockit._7.ClassTest$1.it from class org.duderino.injection.jmockit._7.Dependency

Tests run: 7, Failures: 1, Errors: 0, Skipped: 0
<br /></pre> Assuming there is a publicly accessible 'it' member with the same
    type as the real, non-mocked instance, JMockit will automatically copy the
    real, non-mocked instance reference into the 'it' attribute.   While not
    tested, getting the data type wrong would probably produced a
    ClassCastException.<br />
    <br />
    The other special gotcha is the 'reentrant = true' qualifier on the @Mock
    annotation.   Without this qualifier JMockit will still redirect calls to
    the real instance to the mock.   That is, the mock will call itself
    recursively, generating a stack overflow that looks like this:<br />
    <br />
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 7, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.668 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._7.ClassTest)  Time elapsed: 0.095 sec  &lt;&lt;&lt; FAILURE!
java.lang.StackOverflowError
	at java.util.HashMap.get(HashMap.java:298)
	at java.util.Collections$SynchronizedMap.get(Collections.java:1975)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.java:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.java:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
<br />...<br />	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.java:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._7.ClassTest)

Tests run: 7, Failures: 1, Errors: 0, Skipped: 0
<br /></pre>
    <h2>9. Inject hand-coded mocks or stubs </h2>
    Well, this one is kinda a 'duh'.  Every example so far has injected a
    hand-coded mock. <br />
    <h2>10. Mock/stub injection can be toggled</h2>
    <h2>11. Mock/stub injection can be narrowly targeted</h2>
    <h2>12. Mock/stub out any implementation of an interface</h2>
    <p>TODO - use case - dependency injection frameworks where the
      implementation of an interface is not known in advance and the code under
      test only knows of the interface.</p>
    <p></p>
    <h2>13. Safely mock/stub out class library</h2>
    <p>Can core classes in the class library be safely mocked out without
      interfering with the virtual machine?<br />
    </p>
    <p>Configuration.java<br />
    </p>
    <pre>package org.duderino.injection.jmockit._1;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.FileInputStream;
import java.util.HashMap;
import java.util.Map;

public class Configuration {
    private Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    private final String path;

    public Configuration(String path) throws Exception {
        this.path = path;

        reload();
    }

    public String get(String key) {
        return map.get(key);
    }

    public void reload() throws Exception {
        map.clear();

        DocumentBuilder docBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();

        Document document = docBuilder.parse(new FileInputStream(path));

        NodeList settings = document.getElementsByTagName("setting");

        for (int i = 0; i &lt; settings.getLength(); ++i) {
            Node setting = settings.item(i);

            NodeList children = setting.getChildNodes();

            String key = null;
            String value = null;

            for (int j = 0; j &lt; children.getLength(); ++j) {
                Node child = children.item(j);

                if ("key".equals(child.getNodeName())) {
                    key = child.getNodeValue();
                    continue;
                }

                if ("value".equals(child.getNodeName())) {
                    value = child.getNodeValue();
                    continue;
                }
            }

            if (null != key) {
                map.put(key, value);
            }
        }
    }
}
<br /></pre> ConfigurationTest.java<br />
    <pre>package org.duderino.injection.jmockit._1;

import mockit.Mock;
import mockit.Mockit;
import org.testng.annotations.Test;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;

public class ConfigurationTest {
    @Test
    public void testCheck() throws Exception {
        final String xml = "&lt;settings&gt;&lt;setting&gt;&lt;key&gt;foo&lt;/key&gt;&lt;value&gt;bar&lt;/value&gt;&lt;/setting&gt;&lt;/settings&gt;";

        Mockit.setUpMock(FileInputStream.class, new InputStream() {
            private byte[] bytes = xml.getBytes("UTF-8");
            private int index = 0;

            @Mock
            public int read() throws IOException {
                if (index &gt;= bytes.length) {
                    return 0;
                }

                return bytes[index++];
            }

            @Mock
            private void open(String name) throws FileNotFoundException {
                // do nothing
            }
        });

        Configuration configuration = new Configuration("dummy path");

        assert "bar".equals(configuration.get("foo"));
    }
}
<br /></pre> Output:<br />
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running TestSuite
WARNING: JMockit was initialized on demand, which may cause certain tests to fail;
please check the documentation for better ways to get it initialized.
ZoneInfo: Bad file descriptor
ZoneInfo: Bad file descriptor
ZoneInfo: Bad file descriptor
Tests run: 2, Failures: 2, Errors: 0, Skipped: 0, Time elapsed: 0.779 sec &lt;&lt;&lt; FAILURE!
testCheck(org.duderino.injection.jmockit._1.ConfigurationTest)  Time elapsed: 0.382 sec  &lt;&lt;&lt; FAILURE!
java.lang.NoClassDefFoundError: org/duderino/injection/jmockit/_1/Configuration
	at org.duderino.injection.jmockit._1.ConfigurationTest.testCheck(ConfigurationTest.java:36)
Caused by: java.lang.ClassNotFoundException: org.duderino.injection.jmockit._1.Configuration
	at java.net.URLClassLoader$1.run(URLClassLoader.java:199)
	at java.security.AccessController.doPrivileged(Native Method)
	at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
	... 35 more
Caused by: java.io.IOException: Bad file descriptor
	at java.io.FileInputStream.readBytes(Native Method)
	at java.io.FileInputStream.read(FileInputStream.java:220)
	at sun.misc.Resource.getBytes(Resource.java:108)
	at java.net.URLClassLoader.defineClass(URLClassLoader.java:257)
	at java.net.URLClassLoader.access$000(URLClassLoader.java:58)
	at java.net.URLClassLoader$1.run(URLClassLoader.java:197)
	... 40 more
testCheck(org.duderino.injection.jmockit.basic.Y2KCheckerTest)  Time elapsed: 0.01 sec  &lt;&lt;&lt; FAILURE!
</pre>
    <h2>14. Inject async-friendly mocks/stubs. </h2>
    <h2>15. Inject thread-friendly mocks/stubs.</h2>
    <h2>16. Associate assertions in hand-coded mocks or stubs with test cases in
      same thread</h2>
    <h2>17. Associate assertions in hand-coded mocks or stubs with test cases in
      different thread</h2>
    <br />
    <br />
  

</body></html>