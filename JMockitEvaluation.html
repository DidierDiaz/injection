<!--?xml version="1.0" encoding="UTF-8"?-->
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <title>JMockit Evaluation</title>
  </head>
  <body>
    <h1>JMockit Evaluation</h1>
    <p>See <a href="https://github.com/duderino/injection">https://github.com/duderino/injection</a>
      for complete source code.<br />
    </p>
    <h2>1. Inject test doubles without changing the API</h2>
    <p>Class.java:<br />

    </p><pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}<br /></pre>
    Dependency.java:<br />
    <pre>public class Dependency {
    public int generate() {
        return 999;
    }
}<br /></pre>
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, new Dependency() {
            @Mock
            @Override
            public int generate() {
                return 123;
            }
        });

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /><br /></pre>
    
    <h2>2. Replace final/non-virtual functions with test doubles<br />
</h2>
    Change dependency to be final so our mock cannot subclass it.<br />
    <br />
    Dependency.java:<br />
    <pre>public final class Dependency {
    public final int generate() {
        return 999;
    }
}</pre>
    The class under test doesn't change.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}
<br /></pre> The test case can no longer use Java's anonymous inner class
    mechanism since the dependency cannot be subclassed.   Instead it has to use
    a static/regular class with JMockit's @MockClass annotation.   The
    annotation tells JMockit which class the mock is meant to replace.   It
    works, but it is a bit less natural.<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        public int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /></pre>
    JMockit also supports an alternative mechanism for these cases via its
    MockUp generic class.   The authors recommend this as a replacement for the
    convenience of anonymous mock classes, but the approach is arguably more
    obscure.<br />
    <br />
    ClassTestAlternative.java:<br />
    <pre>public class ClassTestAlternative {
    @Test
    public void testIt() {
        new MockUp&lt;Dependency&gt;() {
            @Mock
            public int generate() {
                return 123;
            }
        };


        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /></pre>
    <h2>3. Replace static functions with test doubles<br />
</h2>
    Here we change our dependency's method to be static.<br />
    <br />
    Dependency.java:<br />
    <pre>public class Dependency {
    public static int generate() {
        return 999;
    }
}
</pre> The class under test no longer instantiates the dependency and instead
    calls its static method.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    public int generate() {
        return Dependency.generate() * 2;
    }
}
<br /></pre> The static method can be mocked out using the same mechanism used
    in the previous example.<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        public static int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}</pre>
    <h2>4. Replace constructors with test doubles<br />
</h2>
    Here we change our dependency to take an argument in its constructor.<br />
    <br />
    Dependency.java:<br />
    <pre>public class Dependency {
    private int value;

    public Dependency(int value) {
        this.value = value;
    }

    public int generate() {
        return value;
    }
}
</pre> The class under test is similarly modified to pass the argument through
    its constructor to the dependency's constructor.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    private Dependency dependency = new Dependency(999);

    public int generate() {
        return dependency.generate() * 2;
    }
}
<br /></pre> TODO<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        void $init(int value) {
            assert 999 == value;
        }

        @Mock
        public static int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /></pre>Unlike Moles, JMockit has some ability to modify the object
 in the $init constructor, but it's limited by the accessibility of the 
object's members.   If, for instance, we made the value field public, we
 could change its value in the $init constructor and avoid overriding 
the generate method:<br />
<pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        public Dependency it;

        @Mock
        void $init(int value) {
            assert 999 == value;

            it.value = 123;  // Compiles only if Dependency.value is accessible
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /></pre>
TODO - mention use of Dependency it and relate to section 8.<br />
<h2>5. Replace anonymous inner classes with test doubles<br />
</h2>
    Sometimes the class under test creates an anonymous inner class that we'd
    like to mock out.   This is a particularly hard problem because the inner
    class may call back on the class under test's internals.<br />
    <br />
    Either JMockit does not support this or I simply couldn't figure out how to
    do it.   This is what I tried to do...<br />
    <br />
    First, I turned the Dependency into an interface.<br />
    <br />
    Dependency.java:<br />
    <pre>public interface Dependency {
    int generate();
}
</pre> Next I modified the class under test to instantiate an anonymous
    implementation of the interface.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    public int generate() {
       Dependency dependency = new Dependency() {
           @Override
           public int generate() {
               return 999;
           }
       };

        return dependency.generate() * 2;
    }
}<br /></pre>
    Finally the test case was modified to inject a mock version of the
    Dependency.<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        public int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}
</pre> Unfortunately JMockit threw a "Not a modifiable class"
    IllegalArgumentException when the test was run:<br />
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 1, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.42 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._5.ClassTest)  Time elapsed: 0.033 sec  &lt;&lt;&lt; FAILURE!
java.lang.IllegalArgumentException: Not a modifiable class: org.duderino.injection.jmockit._5.Dependency
	at org.duderino.injection.jmockit._5.ClassTest.testIt(ClassTest.java:22)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._5.ClassTest): Not a modifiable class: org.duderino.injection.jmockit._5.Dependency

Tests run: 1, Failures: 1, Errors: 0, Skipped: 0
<br /></pre>
    <h2>6. Replace inaccessible (e.g., private) inner classes with test doubles<br />
</h2>
    Extending on the previous example, it appears that JMockit must have access
    to the definition of every class it needs to mock out.   Private inner
    classes, static or not, are not visible to the JMockit annotations so they
    break compilation.<br />
    <br />
    For this test we moved the Dependency class into the Class class.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    private static class Dependency {
        public int generate() {
            return 999;
        }
    }

    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}<br /></pre>
    Next we tried to inject a mock implementation in the test case.<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    @MockClass(realClass = Class.Dependency.class)
    public static class MockDependency {
        @Mock
        public int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Class.Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}

</pre> The result was a predictable compilation error:<br />
    <pre>[INFO] -------------------------------------------------------------
[ERROR] COMPILATION ERROR : 
[INFO] -------------------------------------------------------------
[ERROR] /Users/blattj/dev/injection/src/test/java/org/duderino/injection/jmockit/_6/ClassTest.java:[12,32] org.duderino.injection.jmockit._6.Class.Dependency has private access in org.duderino.injection.jmockit._6.Class
[ERROR] /Users/blattj/dev/injection/src/test/java/org/duderino/injection/jmockit/_6/ClassTest.java:[22,30] org.duderino.injection.jmockit._6.Class.Dependency has private access in org.duderino.injection.jmockit._6.Class
[INFO] 2 errors 

<br /></pre> The same results were observed by omitting the 'static' qualifier.<br />
    <h2>7. Replace subclass and superclass functions with test doubles<br />
</h2>
    <p>TODO - mock out 1 method in superclass and 1 method in subclass.   Might
      be an exclusive OR.</p>
<pre>public class SuperDependency {
    public int generate() {
        return 999;
    }

    public int superGenerate() {
        return 999;
    }
}<br /></pre>
TODO<br />
<pre>public class SubDependency extends SuperDependency {
    @Override
    public int generate() {
        return 333;
    }

    public int subGenerate() {
        return 333;
    }
}<br /></pre>
TODO<br />
<pre>public class Class {
    private SubDependency dependency = new SubDependency();

    public int generate() {
        return 2 * dependency.generate();
    }

    public int superGenerate() {
        return 2 * dependency.superGenerate();
    }

    public int subGenerate() {
        return 2 * dependency.subGenerate();
    }
}<br /></pre>
TODO<br />
<pre>public class ClassTest {
    @Test
    public void testOverride() {
        Mockit.setUpMock(SubDependency.class, new SubDependency() {
            @Mock
            public int generate() {
                return 123;
            }
        });

        Class clazz = new Class();

        assert 2 * 123 == clazz.generate();
        assert 2 * 333 == clazz.subGenerate();
        assert 2 * 999 == clazz.superGenerate();
    }

    @Test
    public void testOvershadow() {
        Mockit.setUpMock(SuperDependency.class, new SuperDependency() {
            @Mock
            public int generate() {
                return 123;
            }
        });

        Class clazz = new Class();

        assert 2 * 333 == clazz.generate();
        assert 2 * 333 == clazz.subGenerate();
        assert 2 * 999 == clazz.superGenerate();
    }

    @Test
    public void testSuper() {
        Mockit.setUpMock(SuperDependency.class, new SuperDependency() {
            @Mock
            public int superGenerate() {
                return 123;
            }
        });

        Class clazz = new Class();

        assert 2 * 333 == clazz.generate();
        assert 2 * 333 == clazz.subGenerate();
        assert 2 * 123 == clazz.superGenerate();
    }

    @Test
    public void testSub() {
        Mockit.setUpMock(SubDependency.class, new SubDependency() {
            @Mock
            public int subGenerate() {
                return 123;
            }
        });

        Class clazz = new Class();

        assert 2 * 333 == clazz.generate();
        assert 2 * 123 == clazz.subGenerate();
        assert 2 * 999 == clazz.superGenerate();
    }
}<br /></pre>
TODO - note the limitation that mocks must be setUp on the class that 
declared the method!   Relate to Moles which has a similar limitation - 
methods are only generated for methods declared in each class<br />
<pre>    @Test
    public void testSuper() {
        Mockit.setUpMock(SubDependency.class, new SubDependency() {
            @Mock
            public int superGenerate() {
                return 123;
            }
        });

        Class clazz = new Class();

        assert 2 * 333 == clazz.generate();
        assert 2 * 333 == clazz.subGenerate();
        assert 2 * 123 == clazz.superGenerate();
    }<br /></pre>
 TODO - produces:<br />
<pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 11, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.578 sec &lt;&lt;&lt; FAILURE!
testSuper(org.duderino.injection.jmockit._7.ClassTest)  Time elapsed: 0.006 sec  &lt;&lt;&lt; FAILURE!
java.lang.IllegalArgumentException: Matching real methods not found for the following mocks of org.duderino.injection.jmockit._7.ClassTest$3:
int superGenerate()
	at org.duderino.injection.jmockit._7.ClassTest.testSuper(ClassTest.java:43)

Results :

Failed tests:   testSuper(org.duderino.injection.jmockit._7.ClassTest): Matching real methods not found for the following mocks of org.duderino.injection.jmockit._7.ClassTest$3:

Tests run: 11, Failures: 1, Errors: 0, Skipped: 0

<br />
    </pre>

    <h2>8. Inject a test double that delegates to a real instance</h2>TODO<br />
    <br />
    Dependency.java:<br />
    <pre>public class Dependency {
    public int generate() {
        return 999;
    }
}
</pre> And the class under test instantiates and calls the dependency as usual.<br />
    <br />
    Class.java:<br />
    <pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}
<br /></pre>TODO<br />
    <br />
    ClassTest.java:<br />
    <pre>public class ClassTest {
    private static class Count {
        private int value = 0;

        public void increment() {
            ++value;
        }

        public int total() {
            return value;
        }
    }

    @Test
    public void testIt() {
        final Count count = new Count();

        Mockit.setUpMock(Dependency.class, new Dependency() {
            public Dependency it;

            @Mock(reentrant = true)
            @Override
            public int generate() {
                count.increment();

                return it.generate();
            }
        });

        Class clazz = new Class();

        for (int i = 0; i &lt; 10; ++i) {
            assert 999 * 2 == clazz.generate();
        }

        assert count.total() == 10;
    }
}</pre>
    Several special things have to happen when we setup this mock object.<br />
    <br />
    We have to declare a 'public Dependency it;' member.   All three tokens are
    important here.   If the member is declared private, JMockit will throw an
    exception that looks like this:<br />
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 7, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.529 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._7.ClassTest)  Time elapsed: 0.012 sec  &lt;&lt;&lt; FAILURE!
java.lang.IllegalAccessError: tried to access field org.duderino.injection.jmockit._7.ClassTest$1.it from class org.duderino.injection.jmockit._7.Dependency
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
	at org.duderino.injection.jmockit._7.Class.generate(Class.java:10)
	at org.duderino.injection.jmockit._7.ClassTest.testIt(ClassTest.java:37)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._7.ClassTest): tried to access field org.duderino.injection.jmockit._7.ClassTest$1.it from class org.duderino.injection.jmockit._7.Dependency

Tests run: 7, Failures: 1, Errors: 0, Skipped: 0
<br /></pre> Assuming there is a publicly accessible 'it' member with the same
    type as the real, non-mocked instance, JMockit will automatically copy the
    real, non-mocked instance reference into the 'it' attribute.   While not
    tested, getting the data type wrong would probably produced a
    ClassCastException.<br />
    <br />
    The other special gotcha is the 'reentrant = true' qualifier on the @Mock
    annotation.   Without this qualifier JMockit will still redirect calls to
    the real instance to the mock.   That is, the mock will call itself
    recursively, generating a stack overflow that looks like this:<br />
    <br />
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 7, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.668 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._7.ClassTest)  Time elapsed: 0.095 sec  &lt;&lt;&lt; FAILURE!
java.lang.StackOverflowError
	at java.util.HashMap.get(HashMap.java:298)
	at java.util.Collections$SynchronizedMap.get(Collections.java:1975)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.java:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.java:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)
<br />...<br />	at org.duderino.injection.jmockit._7.ClassTest$1.generate(ClassTest.java:26)
	at org.duderino.injection.jmockit._7.Dependency.generate(Dependency.java)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._7.ClassTest)

Tests run: 7, Failures: 1, Errors: 0, Skipped: 0
<br /></pre>
    <h2>9. Inject hand-coded test doubles </h2>
    Well, this one is kinda a 'duh'.  Every example so far has injected a
    hand-coded mock. <br />
    <h2>10. Test double injection can be toggled</h2>Dependency.java:<br />

    
<pre>public class Dependency {
    public int generate() {
        return 999;
    }
}</pre>
TODO<br />

    <br />

    Class.java:<br />

    
<pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}
<br /></pre>
 TODO<br />

    <br />

    ClassTest.java:<br />

    
<pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        public int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();

        Mockit.tearDownMocks(Dependency.class);

        assert 999 * 2 == clazz.generate();

        Mockit.setUpMock(Dependency.class, MockDependency.class);

        assert 123 * 2 == clazz.generate();
    }
}<br /></pre>

    TODO<br />
<br />

    <h2>11. Test double injection can be narrowly targeted</h2>Dependency.java:<br />


    
<pre>public class Dependency {
    public int generate() {
        return 999;
    }
}</pre>

TODO<br />


    <br />


    Class.java:<br />


    
<pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() + (2 * dependency.generate());
    }
}
<br /></pre>

 TODO<br />


    <br />


    ClassTest.java:<br />


    
<pre>public class ClassTest {
    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, new Dependency() {
            public Dependency it;
            private int calls = 0;

            @Mock(reentrant = true)
            public int generate() {
                return ++calls == 2 ? 123 : it.generate();
            }
        });

        Class clazz = new Class();

        assert 999 + (2 * 123) == clazz.generate();
    }
}<br /></pre>


    TODO - mention same issues as 8.   Dependency must be public.  @mock must be reentrant or else stack overflow.<br />
<br />

    <h2>12. Replace any implementation of an interface with a test double<br />
</h2>
    
<p>TODO - use case - dependency injection frameworks where the
      implementation of an interface is not known in advance and the code under
      test only knows of the interface.</p>

    
<p>Dependency.cs:<br />
    </p>

    
<pre>public interface Dependency {
    int generate();
}
</pre>
 Class.cs:<br />

    
<pre>public class Class {
    public class DependencyImpl implements Dependency {
        public int generate() {
               return 999;
           }
    }

    private Dependency dependency = new DependencyImpl();

    public int generate() {
        return dependency.generate() * 2;
    }
}<br /></pre>

    ClassTest.cs:<br />

    
<pre>public class ClassTest {
    @MockClass(realClass = Dependency.class)
    public static class MockDependency {
        @Mock
        public int generate() {
            return 123;
        }
    }

    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, MockDependency.class);

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /></pre>
TODO<br />
<pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 14, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.595 sec &lt;&lt;&lt; FAILURE!
testIt(org.duderino.injection.jmockit._12.ClassTest)  Time elapsed: 0.003 sec  &lt;&lt;&lt; FAILURE!
java.lang.IllegalArgumentException: Not a modifiable class: org.duderino.injection.jmockit._12.Dependency
	at org.duderino.injection.jmockit._12.ClassTest.testIt(ClassTest.java:22)

Results :

Failed tests:   testIt(org.duderino.injection.jmockit._12.ClassTest): Not a modifiable class: org.duderino.injection.jmockit._12.Dependency

Tests run: 14, Failures: 1, Errors: 0, Skipped: 0
<br /></pre>

    <p></p>
    <h2>13. Safely replace a class library class with a test double<br />
</h2>
    <p>Can core classes in the class library be safely mocked out without
      interfering with the virtual machine?</p>
<p><br />
</p>
Class.java:<br />
<pre>public class Class {
    public int generate() throws Exception {
        FileInputStream stream = new FileInputStream("foo");

        byte[] bytes = new byte[3];

        stream.read(bytes);

        String string = new String(bytes, "ASCII");

        return 2 * Integer.parseInt(string);
    }
}<br /></pre>
ClassTest.java:<br />
<pre>public class ClassTest {
    @Test
    public void test() throws Exception {
        Mockit.setUpMock(FileInputStream.class, new InputStream() {
            private byte[] bytes = new byte[]{0x31, 0x32, 0x33};
            private int index = 0;

            @Mock
            void $init(String fileName) {
                assert "foo".equals(fileName);
            }

            @Mock
            public int read() throws IOException {
                if (index &gt;= bytes.length) {
                    return 0;
                }

                return bytes[index++];
            }

            @Mock
            public int read(byte[] out) throws IOException {
                for (int i = 0; i &lt; out.length; ++i) {
                    int result = read();

                    if (0 == result) {
                        return i;
                    }

                    out[i] = bytes[i];
                }

                return out.length;
            }
        });

        Class clazz = new Class();

        assert 2 * 123 == clazz.generate();
    }
}<br /></pre>

    <p>Configuration.java:<br />
    </p>
    <pre>public class Configuration {
    private Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    private final String path;

    public Configuration(String path) throws Exception {
        this.path = path;

        reload();
    }

    public String get(String key) {
        return map.get(key);
    }

    public void reload() throws Exception {
        map.clear();

        DocumentBuilder docBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();

        Document document = docBuilder.parse(new FileInputStream(path));

        NodeList settings = document.getElementsByTagName("setting");

        for (int i = 0; i &lt; settings.getLength(); ++i) {
            Node setting = settings.item(i);

            NodeList children = setting.getChildNodes();

            String key = null;
            String value = null;

            for (int j = 0; j &lt; children.getLength(); ++j) {
                Node child = children.item(j);

                if ("key".equals(child.getNodeName())) {
                    key = child.getNodeValue();
                    continue;
                }

                if ("value".equals(child.getNodeName())) {
                    value = child.getNodeValue();
                    continue;
                }
            }

            if (null != key) {
                map.put(key, value);
            }
        }
    }
}
<br /></pre> ConfigurationTest.java:<br />
    <pre>public class ConfigurationTest {
    @Test
    public void test() throws Exception {
        final String xml = "&lt;settings&gt;&lt;setting&gt;&lt;key&gt;foo&lt;/key&gt;&lt;value&gt;bar&lt;/value&gt;&lt;/setting&gt;&lt;/settings&gt;";

        Mockit.setUpMock(FileInputStream.class, new InputStream() {
            private byte[] bytes = xml.getBytes();
            private int index = 0;

            @Mock
            void $init(String fileName) {
            }

            @Mock
            public int read() throws IOException {
                if (index &gt;= bytes.length) {
                    return 0;
                }

                return bytes[index++];
            }

            @Mock
            public int read(byte[] out) throws IOException {
                for (int i = 0; i &lt; out.length; ++i) {
                    int result = read();

                    if (0 == result) {
                        return i;
                    }

                    out[i] = bytes[i];
                }

                return out.length;
            }
        });

        Configuration configuration = new Configuration("README");

        assert "bar".equals(configuration.get("foo"));
    }
}
<br /></pre> Output:<br />
    <pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Tests run: 15, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.718 sec &lt;&lt;&lt; FAILURE!
test(org.duderino.injection.jmockit._13.ConfigurationTest)  Time elapsed: 0.022 sec  &lt;&lt;&lt; FAILURE!
java.io.IOException: Bad file descriptor
	at java.io.FileInputStream.readBytes(Native Method)
	at java.io.FileInputStream.read(FileInputStream.java:220)
	at com.sun.org.apache.xerces.internal.impl.XMLEntityManager$RewindableInputStream.read(XMLEntityManager.java:2961)
	at com.sun.org.apache.xerces.internal.impl.io.UTF8Reader.read(UTF8Reader.java:299)
	at com.sun.org.apache.xerces.internal.impl.XMLEntityScanner.load(XMLEntityScanner.java:1742)
	at com.sun.org.apache.xerces.internal.impl.XMLEntityScanner.arrangeCapacity(XMLEntityScanner.java:1619)
	at com.sun.org.apache.xerces.internal.impl.XMLEntityScanner.skipString(XMLEntityScanner.java:1657)
	at com.sun.org.apache.xerces.internal.impl.XMLVersionDetector.determineDocVersion(XMLVersionDetector.java:193)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:772)
	at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:737)
	at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:119)
	at com.sun.org.apache.xerces.internal.parsers.DOMParser.parse(DOMParser.java:235)
	at com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl.parse(DocumentBuilderImpl.java:284)
	at javax.xml.parsers.DocumentBuilder.parse(DocumentBuilder.java:124)
	at org.duderino.injection.jmockit._13.Configuration.reload(Configuration.java:32)
	at org.duderino.injection.jmockit._13.Configuration.&lt;init&gt;(Configuration.java:20)
	at org.duderino.injection.jmockit._13.ConfigurationTest.test(ConfigurationTest.java:49)

Results :

Failed tests:   test(org.duderino.injection.jmockit._13.ConfigurationTest): Bad file descriptor

Tests run: 15, Failures: 1, Errors: 0, Skipped: 0


</pre>
    <h2>14. Inject async-friendly test doubles </h2>
<p>Dependency.cs:<br />
    </p>

    
<pre>public class Dependency {
    public void generate(Class clazz) {
        clazz.callback(999);
    }
}
</pre>
 Class.cs:<br />

    
<pre>public class Class {
    private Dependency dependency = new Dependency();
    private int result = 0;

    public void callback(int result) {
        this.result = result;
    }

    public int generate() {
        dependency.generate(this);

        return 2 * result;
    }
}<br /></pre>

    ClassTest.cs:<br />

    
<pre>public class ClassTest {
    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, new Dependency() {
            @Mock
            @Override
            public void generate(Class clazz) {
                clazz.callback(123);
            }
        });

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}</pre>
<h2>15. Inject thread-friendly test doubles<br />
</h2>

    TODO - Can the injection mechanism be used concurrently?   Are mocks/stubs thread-specific?
<p>Dependency.cs:</p>

    
<pre>public class Dependency {
    public long generate() {
        return Thread.currentThread().getId() + 999;
    }
}<br /></pre>

    Class.cs:<br />

    
<pre>public class Class {
    private Dependency dependency = new Dependency();

    public long generate() {
        return dependency.generate() * 2;
    }
}<br /></pre>

    
    ClassTest.cs:<br />

    
<pre>public class ClassTest implements Runnable {
    @Override
    public void run() {
        long magicNumber = Thread.currentThread().getId() + 123;

        Mockit.setUpMock(Dependency.class, new Dependency() {
            @Mock
            @Override
            public long generate() {
                return Thread.currentThread().getId() + 123;
            }
        });

        Class clazz = new Class();

        assert 2 * magicNumber == clazz.generate();
    }

    @Test
    public void testIt() throws InterruptedException {
        Thread[] threads = new Thread[1000];

        for (int i = 0; i &lt; threads.length; ++i) {
            threads[i] = new Thread(this);
        }

        for (int i = 0; i &lt; threads.length; ++i) {
            threads[i].start();
        }

        for (int i = 0; i &lt; threads.length; ++i) {
            threads[i].join();
        }
    }
}<br /></pre>

    <h2>16. Associate failed assertions in test doubles with test cases in
      same thread</h2>
<p>Dependency.cs:</p>

    
<pre>public class Dependency {
    public int generate() {
        return 999;
    }
}<br /></pre>

    Class.cs:<br />

    
<pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}<br /></pre>

    ClassTest.cs:<br />

    
<pre>public class ClassTest {
    @Test
    public void testIt() {
        Mockit.setUpMock(Dependency.class, new Dependency() {
            @Mock
            @Override
            public int generate() {
                assert 1 == 2;

                return 123;
            }
        });

        Class clazz = new Class();

        assert 123 * 2 == clazz.generate();
    }
}<br /></pre>
testng-results.xml:<br />
<pre>      &lt;class name="org.duderino.injection.jmockit._16.ClassTest"&gt;
        &lt;test-method status="FAIL" signature="testIt()" name="testIt" duration-ms="8" started-at="2011-12-03T17:50:15Z" finished-at="2011-12-03T17:50:15Z"&gt;
          &lt;exception class="java.lang.AssertionError"&gt;
            &lt;full-stacktrace&gt;
              &lt;![CDATA[java.lang.AssertionError
        at org.duderino.injection.jmockit._16.ClassTest$1.generate(ClassTest.java:17)
        at org.duderino.injection.jmockit._16.Dependency.generate(Dependency.java)
        at org.duderino.injection.jmockit._16.Class.generate(Class.java:10)
        at org.duderino.injection.jmockit._16.ClassTest.testIt(ClassTest.java:25)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.apache.maven.surefire.testng.TestNGExecutor.run(TestNGExecutor.java:122)
        at org.apache.maven.surefire.testng.TestNGXmlTestSuite.execute(TestNGXmlTestSuite.java:92)
        at org.apache.maven.surefire.testng.TestNGProvider.invoke(TestNGProvider.java:101)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:164)
        at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:110)
        at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:172)
        at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcessWhenForked(SurefireStarter.java:104)
        at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:70)
]]&gt;
            &lt;/full-stacktrace&gt;
          &lt;/exception&gt;
        &lt;/test-method&gt;
      &lt;/class&gt;
<br /></pre>
<br />

    <h2>17. Associate failed assertions in test doubles with test cases in
      different threads</h2>
    TODO - emphasize that this is not a property of JMockit but rather of TestNG.<br />
<br />
<p>Dependency.cs:</p>


    
<pre>public class Dependency {
    public int generate() {
        return 999;
    }
}<br /></pre>


    Class.cs:<br />


    
<pre>public class Class {
    private Dependency dependency = new Dependency();

    public int generate() {
        return dependency.generate() * 2;
    }
}<br /></pre>


    ClassTest.cs:<br />


    
<pre>public class ClassTest implements Runnable {
    public void run() {
        assert 1 == 2;
    }

    @Test
    public void test() throws InterruptedException {
        Thread[] threads = new Thread[10];

        for (int i = 0; i &lt; threads.length; ++i) {
            threads[i] = new Thread(this);
        }

        for (int i = 0; i &lt; threads.length; ++i) {
            threads[i].start();
        }

        for (int i = 0; i &lt; threads.length; ++i) {
            threads[i].join();
        }
    }
}<br /></pre>

testng-results.xml:<br />

<pre>      &lt;class name="org.duderino.injection.jmockit._17.ClassTest"&gt;
        &lt;test-method status="PASS" signature="test()" name="test" duration-ms="11" started-at="2011-12-03T18:02:46Z" finished-at="2011-12-03T18:02:46Z"&gt;
        &lt;/test-method&gt;
      &lt;/class&gt;
<br /></pre>
console:<br />
<pre>-------------------------------------------------------
 T E S T S
-------------------------------------------------------
JMockit: loaded external tool mockit.coverage.CodeCoverage
Running TestSuite
Exception in thread "Thread-1004" Exception in thread "Thread-1003" java.lang.AssertionError
	at org.duderino.injection.jmockit._17.ClassTest.run(ClassTest.java:11)
	at java.lang.Thread.run(Thread.java:680)
java.lang.AssertionError
	at org.duderino.injection.jmockit._17.ClassTest.run(ClassTest.java:11)
	at java.lang.Thread.run(Thread.java:680)
Exception in thread "Thread-1005" java.lang.AssertionError
	at org.duderino.injection.jmockit._17.ClassTest.run(ClassTest.java:11)
	at java.lang.Thread.run(Thread.java:680)
Exception in thread "Thread-1012" java.lang.AssertionError
	at org.duderino.injection.jmockit._17.ClassTest.run(ClassTest.java:11)
	at java.lang.Thread.run(Thread.java:680)
Exception in thread "Thread-1011" java.lang.AssertionError
	at org.duderino.injection.jmockit._17.ClassTest.run(ClassTest.java:11)
	at java.lang.Thread.run(Thread.java:680)
Exception in thread "Thread-1010" java.lang.AssertionError
	at org.duderino.injection.jmockit._17.ClassTest.run(ClassTest.java:11)
	at java.lang.Thread.run(Thread.java:680)
Exception in thread "Thread-1009" java.lang.AssertionError
	at org.duderino.injection.jmockit._17.ClassTest.run(ClassTest.java:11)
	at java.lang.Thread.run(Thread.java:680)
Exception in thread "Thread-1008" java.lang.AssertionError
	at org.duderino.injection.jmockit._17.ClassTest.run(ClassTest.java:11)
	at java.lang.Thread.run(Thread.java:680)
Exception in thread "Thread-1007" java.lang.AssertionError
	at org.duderino.injection.jmockit._17.ClassTest.run(ClassTest.java:11)
	at java.lang.Thread.run(Thread.java:680)
Exception in thread "Thread-1006" java.lang.AssertionError
	at org.duderino.injection.jmockit._17.ClassTest.run(ClassTest.java:11)
	at java.lang.Thread.run(Thread.java:680)
Tests run: 18, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.811 sec

Results :

Tests run: 18, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 5.925s
[INFO] Finished at: Sat Dec 03 18:02:46 PST 2011
[INFO] Final Memory: 9M/81M
[INFO] ------------------------------------------------------------------------
<br /></pre>

  

</body></html>