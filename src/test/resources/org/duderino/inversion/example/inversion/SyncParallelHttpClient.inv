package org.duderino.inversion.example.inversion;

import org.apache.http.HttpResponse;
import org.apache.http.HttpVersion;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpUriRequest;
import org.apache.http.impl.nio.client.DefaultHttpAsyncClient;
import org.apache.http.message.BasicHttpResponse;
import org.apache.http.nio.concurrent.FutureCallback;
import org.apache.http.nio.reactor.IOReactorException;

import java.lang.reflect.Array;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.logging.Level;
import java.util.logging.Logger;

public class SyncParallelHttpClient {
    private static Logger logger = Logger.getLogger(org.duderino.inversion.example.java.AsyncParallelHttpClient.class.getName());

    // Don't want to make these class variables because then they might be shared illegally between threads
    // private final DefaultHttpAsyncClient client = new DefaultHttpAsyncClient();
    // private final Map<HttpUriRequest, Object> results = new HashMap<HttpUriRequest, Object>();

    beforeSuite {
        SyncParallelHttpClient client = new SyncParallelHttpClient();
    }

    afterSuite {
    }

    beforeTest {
    }

    afterTest {
    }

    public SyncParallelHttpClient() {
    }

    public Map<String, Object> fetch(String[] URLs) throws IOReactorException {
        final DefaultHttpAsyncClient client = [
            default: new DefaultHttpAsyncClient(),
            test: new DefaultHttpAsyncClient() {
                @Override
                public Future<HttpResponse> execute(HttpUriRequest request, FutureCallback<HttpResponse> callback) {
                    // Java 7 Strings in switch statements will make this cleaner
                    if ("cancelled.example.com".equals(request.getURI().getHost())) {
                        callback.cancelled();
                    } else if ("failed.example.com".equals(request.getURI().getHost())) {
                        callback.failed(new Exception("Should fail"));
                    } else if ("completed.example.com".equals(request.getURI().getHost())) {
                        callback.completed(new BasicHttpResponse(HttpVersion.HTTP_1_1, 200, "OK"));
                    }

                    return null;
                }
            };
        ];

        Map<String, Object> results = new HashMap<String, Object>();

        client.start();

        Future<HttpResponse>[] futures = (Future<HttpResponse>[]) Array.newInstance(Future.class, URLs.length);
        
        try {
            for (int i = 0; i < URLs.length; ++i) {
                futures[i] = client.execute(new HttpGet(URLs[i]), null);
            }

            for (int i = 0; i < URLs.length; ++i) {
                try {
                    HttpResponse response = futures[i].get();

                    results.put(URLs[i], response);
                } catch (ExecutionException ex) {
                    results.put(URLs[i], ex.getCause());
                } catch (Exception ex) {
                    results.put(URLs[i], ex);
                }
            }
        } finally {
            try {
                client.shutdown();
            } catch (InterruptedException ex) {
                if (logger.isLoggable(Level.WARNING)) {
                    logger.log(Level.WARNING, "Cannot shutdown http client", ex);
                }
            }
        }

        return results;
    }

    test fetch {
        String[] URLs = { "cancelled.example.com", "failed.example.com", "completed.example.com" };

        Map<String, Object> results = client.fetch(URLs);

        assert results.get("cancelled.example.com") instanceof CancellationException;
        assert results.get("failed.example.com") instanceof Exception;
        assert results.get("completed.example.com") instanceof HttpResponse;
    }
}
